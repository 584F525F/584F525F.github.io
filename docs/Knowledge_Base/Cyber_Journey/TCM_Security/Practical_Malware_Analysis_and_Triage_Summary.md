!!! info ""

    ### Tools list

    ??? info "FLARE-VM"
        #### FLARE-VM Tool List

        - [strings/FLOSS](https://github.com/mandiant/flare-floss)
        - [PEView](http://wjradburn.com/software/)
        - [upx (not used but referenced)](https://upx.github.io/)
        - [PEStudio](https://www.winitor.com/download)
        - [Capa](https://github.com/mandiant/capa)
        - [Wireshark](https://www.wireshark.org/)
        - [Sysinternals (Procmon, TCPView)](https://learn.microsoft.comn-us/sysinternals/downloads/) | [Download sysinternals all](https://download.sysinternals.com/files/SysinternalsSuite.zip)
        - [nc/ncat](https://nmap.org/download)
        - [Cutter](https://github.com/rizinorg/cutter)
        - [x32/x64dbg](https://x64dbg.com/)
        - [Process Hacker 2 (now known as System Informer)](https:/ysteminformer.sourceforge.io/)
        - [scdbg](https://github.com/dzzie/SCDBG)
        - [dnSpy/dnSpyEx](https://github.com/dnSpyEx/dnSpy)
        - [PEBear](https://hshrzd.wordpress.com/pe-bear/)
        - [YARA](https://github.com/VirusTotal/yara)

    ??? info "REMnux"
    
        #### REMnux Tool List

        - base64 (built in Linux bin)
        - [OLEdump](https://github.com/DidierStevens/DidierStevensSuite/blob/master/oledump.py)
        - [MobSF github](https://github.com/MobSF/Mobile-Security-Framework-MobSF) | [(Docker Container)](https://hub.docker.com/r/opensecurity/mobile-security-framework-mobsf/)
        - [INetSim](https://www.inetsim.org/)


!!! info ""

    ### Get your Malware Samples here

    - [PMAT Labs](https://github.com/HuskyHacks/PMAT-labs)
    - [theZoo](https://github.com/ytisf/theZoo)
    - [vx-underground main site](https://www.vx-underground.org/)
    - [vx-underground GitHub repo](https://github.com/vxunderground/MalwareSourceCode)
    - [Zeltser Resources](https://zeltser.com/malware-sample-sources/)
    - [MalwareBazaar](https://bazaar.abuse.ch/###)



!!! info ""

    ### Basic Static Analysis

    **Basic**: Limited Triage approach to the tools and techniques we are using

    **Static**: Not running the binary

    ??? info "Binary Hashes"
        
        #### Pulling the Binary Hashes

        Pull the file hashes (Sha256 and MD5)

        ```bash
        sha256sum.exe <Malware_file_name.extension>
        md5sum.exe <Malware_file_name.extension>
        ```

        If using Cmder

        ```powershell
        Get-filehash -Algorithm SHA256 <Malware_file_name.extension>
        ```

        Submit the hashes to [VirusTotal](https://www.virustotal.com/gui/home/search) and see if you get something promising back!


    ??? info "Binary strings"

        #### strings

        Extract the Binary strings, you can use **strings** or **FLOSS**.
        Floss will pull any array of Char > len(4) and terminated with a NullByte

        ```bash
        floss <Malware_file_name.extension>

        #-n will look for a minimum string length of 8, you can change the value based on your needs.
        floss -n 8 <Malware_file_name.extension>
        ```

        Look through the output for any usable information, one of the most telling is the FLOSS static Unicode strings. Keep in mind that someone could put that there in purpose to mislead you while Analyzing the Malware sample.

    ??? info "Portable Executable Viewer - PEView"

        #### PEView
        
        run PEView > folder browser select "All File (*.*)" > locate your Malware sample > Click Open > It should load your Malware into the program

        **pFile** column: the offset of the Bytes, where in relation to the beginning of the Program did these Bits exist

        **Value** column: Char representation of the Bytes. Value MZ is a Windows EXE (Magic Byte tells what the file signature is)

        !!! example ""
            If you want to learn more about [Magic Bytes](https://www.netspi.com/blog/technical-blog/web-application-pentesting/magic-bytes-identifying-common-file-formats-at-a-glance/)

            [Interesting way of abusing the Magic Byte](https://medium.com/@d.harish008/what-is-a-magic-byte-and-how-to-exploit-1e286da1c198)

        **IMAGE_MT_HEADERS** > IMAGE_FILE_HEADER > Time Date Stamp
        - This is the time of build but sometimes this can be incorrect.
        - If the program was compiled with borland delphi compiler, the compile date will always be 1992
        
        **IMAGE_SECTION_HEADER.text**
        - **Virtual Size** (The amount of the data on disk when the Binary is run) & **Size of Raw Data **
        - Compare these HEX value using calc HEX
        - If the **Size of Raw Data ** < **Virtual Size** this could mean it's a packed Binary
          - In packed Binary the difference is very significant
          - ![img](/Knowledge_Base/images/PMA_Summary_1_2.png)

        **SECTION.rdata** > IMPORT_Address_Table
        
        !!! info ""
            This section is important because of the Windows API (Application Programming Interface)
            - APIs are readily accessible to C and C++ developers, other languages like C# and Rust require wrappers or bindings in order to access these APIs. Source [Windows Developer Blog - making win32 apis more accessible](https://blogs.windows.com/windowsdeveloper/2021/01/21/making-win32-apis-more-accessible-to-more-languages/)
            - What this means is that Malware creators can also make use of the Windows API.
            - [Windows win32 API](https://learn.microsoft.com/en-us/windows/win32/api/)
            
            ![img](/Knowledge_Base/images/PMA_Summary_1_3.png)

        Going back to the **IMPORT_Address_Table**
        
        !!! warning ""
            ##### unpacked Malware
            
            You can see all the Windows API Calls under the Value column for **IMPORT_Address_Table**

            ![img](/Knowledge_Base/images/PMA_Summary_1_0.png)        

        !!! warning ""
            ##### packed Malware

            You will see the packer name UPX in this case `SECTION UPX`
            You won't see all the Windows API calls under the Value column for **IMPORT_Address_Table**
            **LoadLibraryA** & **GetProcAddress** are used to identify other imports at runtime, on runtime it will go find the API calls from the dlls it loads in.

            ![img](/Knowledge_Base/images/PMA_Summary_1_5.png)

        For example if we see ShellExecuteW, we can google for "Windows API Shell ExecuteW", first link gets us to [nf-shellapi-shellexecutea](https://learn.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-shellexecutea) which will explain the API call function.

        Now if you want to get to the point and see exactly what could be malicious, you can check [**MalAPI.io**](https://malapi.io/)


    ??? info "Portable Executable Studio - PEStudio"

        #### PEStudio

        Before we get into it, always keep in mind the type of application and it's functionality when looking for file signatures. In below example you can see ShellExecuteA but the application is putty, which is a part of its functionality.

        ![img](/Knowledge_Base/images/PMA_Summary_s4_2.png)

        Run PEStudio > file > open file > select the malware sample > click Open

        PEStudio simplifies the early stages, when using Basic Static Analysis. For example it gives you the hashes right away, runs strings and presents many more pieces of information.

        ![img](/Knowledge_Base/images/PMA_Summary_1_4.png)


    ??? info "Detecting executable capabilities"

        #### [CAPA](https://github.com/mandiant/capa)

        CAPA detects malicious capabilities in suspicious programs by using a set of rules. Capa has a default rule set, but also has an open-source repository of rules [**CAPA rule repository**](https://github.com/mandiant/capa-rules)

        ![img](/Knowledge_Base/images/PMA_Summary_1_6.png)

        ![img](/Knowledge_Base/images/PMA_Summary_1_7.png)

        From the output we can then use the [**MITRE ATT&CK Framework**](https://attack.mitre.org/). In our example we have T1129, we can check that out through this link [MITRE T1129](https://attack.mitre.org/techniques/T1129/)


!!! info ""

    ### Basic Dynamic Analysis

    Also known as **Heuristic** or **Behavioral** Analysis. Dynamic Analysis means that we will execute/run the Malware and Analyze it.

    We will be looking for **Host Indicators** (Like deleting a local file) & **Network Indicators** (like calling out to the Internet to download a file).

    ??? info "Network Signatures"

        #### Hunting for Network Signatures

        Make sure all the tools are ready before executing the Malware (RemNux, Wireshark Capture on RemNux)

        We can start by looking for the Network Signatures now, based on the Static Analysis we did, we gathered possibly a domain name or a file name it's calling for. We can look for those into our Wireshark Capture.

        Once Network Signatures is complete, we can rollback out VM then run the Malware again to check for Local Signatures.


    ??? info "Local Signatures"

        #### Local Signatures - Procmon

        ??? info "Procmon overview"
        
            ##### overview

            Open Procmon > Click the Filter > setup the filter and click OK

            ![img](/Knowledge_Base/images/PMA_Summary_1_8.png)

            Since we know the process name we can setup something like this
            
            ![img](/Knowledge_Base/images/PMA_Summary_1_9.png)

            You won't see any events until you run the Malware sample

            ![img](/Knowledge_Base/images/PMA_Summary_1_10.png)

            You will now need to sift through the Operations 

            For example in the Static Analysis Stage we found a path with an exe name when we ran strings on the sample, after filtering through operations we found the same path

            ![img](/Knowledge_Base/images/PMA_Summary_1_11.png)

            Now we can go to that path and see what that executable is doing.

            **Keep going through all the interesting strings to gather more information**, try to extract the Malware flow such as if it deletes itself, call to download a file and so on.

            ![img](/Knowledge_Base/images/PMA_Summary_1_12.png)

        ??? info "Procmon common filters"

            ##### procmon filters

            **Common Operations filters**:

            - CreateFile: When a process wants to create a file.
            - WriteFile: When a process writes data to a file.
            - SetRenameInformationFile: When a rename operation occurs on a file.
            - SetDispositionInformationFile: When a file deletion occurs on a file.
            - RegCreateKey: When registry key is created.
            - RegSetValue: When the data for value is set in the registry
            - RegDeleteKey: When a key gets deleted from the registry.
            - RegDeleteValue: When a value gets deleted from the registry.
            - TCP Connect, TCP Receive, UDP Send, UDP Receive: Process is Sending / - Receiving a TCP or UDP connection.
            - Load Image: When a process loads any DLL’s / Executables.
            - Process Create: When a process creates a process.
            - CreatePipe: When a process creates a Pipe.

            **Resources**:

            - [motiba](https://learn.microsoft.com/en-us/archive/blogs/motiba/process-monitor-for-dynamic-malware-analysis)
            - [system_monitor](https://github.com/wuanzhuan/system_monitor?tab=readme-ov-file)
            - [Lonebear69 filter import](https://github.com/Lonebear69/https-github.com-tanc7-procmon-filters)
            - [mindmap](https://www.mindmeister.com/app/map/55334446?fullscreen=1&v=public)


    ??? info "TCP View"

        #### TCP View

        Having TCP View running when we run the malware sample, we can then check the ports the malware is requesting.

        ![img](/Knowledge_Base/images/PMA_Summary_22.png)

        If we see one that's listening, we can go back to our RemNux machine and netcat `nc` that port to interact with the Malware and see what happens

        ![img](/Knowledge_Base/images/PMA_Summary_23.png)

        nc result

        ![img](/Knowledge_Base/images/PMA_Summary_24.png)

        decode the result with base64

        ![img](/Knowledge_Base/images/PMA_Summary_25.png)

        Now we know what it's asking for, a command. We ran the `ipconfig` and came back with a result

        ![img](/Knowledge_Base/images/PMA_Summary_26.png)

        decoded the result and it's showing us the network adapter configuration

        ![img](/Knowledge_Base/images/PMA_Summary_27.png)

        So the above tells us it had command injection capability

        We now can run procmon while interacting with the Malware sample

        ![img](/Knowledge_Base/images/PMA_Summary_28.png)

        We can see that it's sending the results back

        ![img](/Knowledge_Base/images/PMA_Summary_29.png)


    ??? info "Process Tree"

        #### Process Tree

        You will need to de-chain/decouple the Parent Child Process relationship.
        
        ![img](/Knowledge_Base/images/PMA_Summary_2_0_0.png)

        Knowing the PID for the parent process, we can now filter Procmon using Parent PID

        ![img](/Knowledge_Base/images/PMA_Summary_s4_0.png)

        ![img](/Knowledge_Base/images/PMA_Summary_s4_1.png)


    ??? info "Encoded files"

        #### Extracting encoded file

        Lets say you found a base64 string in a command running through powershell.exe

        ![img](/Knowledge_Base/images/PMA_Summary_s4_4.png)

        You can extract that string and decode it, then get the file type of whatever it decoded to

        ![img](/Knowledge_Base/images/PMA_Summary_s4_3.png)

        ```bash
        #decode to a file called out and has no file extension
        echo "XXX_VALUE_XXX" | base64 -d > out
        
        #figure out the file type
        file out
        
        #we can see in the example we have a gzip file
        #now you can extract the file and check its contents
        ```

!!! info ""

    ### Advanced Static Analysis: Assembly Language, Decompiling, & Disassembling Malware


    ??? info "Analysis & Assembly"

        #### Advanced Analysis & Assembly Language


    ??? info "Disassembling & Decompiling"

        #### Disassembling & Decompiling a Malware Dropper: Intro to Cutter


        Sample for this section: [Lab file(s)](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs//2-1.AdvancedStaticAnalysis/Dropper.DownloadFromURL.exe.malz/Dropper.DownloadFromURL.exe.7z)

	    [Lab file(s)](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs/2-1.AdvancedStaticAnalysis)

	    **Errata**
	    Please note that, depending on when you installed FLARE-VM, the installed tools may or may not include Cutter. If you don't see it when searching in the task bar, please download it from the official site here: https://cutter.re/



    ??? info "x86 CPU"

        #### x86 CPU Instructions, Memory Registers, & the Stack



    ??? info "Assembly Instructions & Windows API"

        #### Dropper: Assembly Instructions and the Windows API

        Sample for this section: [Lab file(s)](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs//2-1.AdvancedStaticAnalysis/Dropper.DownloadFromURL.exe.malz/Dropper.DownloadFromURL.exe.7z)

	    [Lab file(s)](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs/2-1.AdvancedStaticAnalysis)


    ??? info "Under a Microscope"

        #### Hello, World! Under a Microscope Part I

        Using cutter > load the malware sample in
        Now we need to see if the application was stripped of it's debug symbols or not, look for the dbg prefix for functions

        ![img](/Knowledge_Base/images/pma_img_s8js_0.png)

        You can also lookup the Disassembly
        ![img](/Knowledge_Base/images/pma_img_s8js_1.png)

        rdata is only used to hold readonly data inside a binary

        ![img](/Knowledge_Base/images/pma_img_s8js_2.png)

        Checking Hexdump

        ![img](/Knowledge_Base/images/pma_img_s8js_3.png)


    ??? info "Advanced Analysis of a Process Injector"

        #### Advanced Analysis of a Process Injector

        Malware that creates remote thread process Injection is common TTP (Tactics, Techniques, and Procedures)

        Process Injection: Open up another process that is running on the host and inject code right into that process and have that code run in that process as if that code was a part of that program in the first place.

        This isn't very stealthy now a days because defenders look for it.

        What does it look like?

        Opening up a process 
        ![img](/Knowledge_Base/images/pma_img_s8js_4.png)

        Next step, same logic, API call and passing parameters

        Allocating an area in memory with the writes to write into that memory

        ![img](/Knowledge_Base/images/pma_img_s8js_5.png)

        Taking the Bytes from the lpBuffer and writing them into that process in the section of memory that we've allocated

        ![img](/Knowledge_Base/images/pma_img_s8js_6.png)

        Create remote thread

        ![img](/Knowledge_Base/images/pma_img_s8js_7.png)

        Looking at the API call in the last screenshot to see what the ate the parameters that are being passed (1st & 4th)
        
        So that would be, 1st is hProcess & 4th is IpStartAddress
        hProcess has value of edi
        IpStartAddress has value of esi

        ![img](/Knowledge_Base/images/pma_img_s8js_8.png)

        and the value of esi that is being passed is
        ![img](/Knowledge_Base/images/pma_img_s8js_9.png)


        If we check the process in Process Hacker, we see the process used was WerFault.exe. Now if we go inspect the Memory we will see an unusual Protection of RW**X**
        
        ![img](/Knowledge_Base/images/pma_img_s9js_0.png)

        If we go into that RW**X** section of WerFault.exe, we will see the actual Bytes of the shell code written into this process

        ![img](/Knowledge_Base/images/pma_img_s9js_1.png)


!!! info ""

    ### Advanced Dynamic Analysis: Debugging Malware


    ??? info "Flow Control & Breakpoints"

        #### x32dbg: Flow Control & Breakpoints

        We will be using Debuggers (x32dbg & x64dbg)

        Load the Malware sample into x32dbg
        
        The CPU window shows the Assembly instructions that the program will execute
        Memory window shows the Memory Registers
        Stack windows shows any value that was pushed or popped from the stack
        
        ![img](/Knowledge_Base/images/PMA-apo-98hs-4.png)

        |Shortcut|Description|
        |:-|:-|
        |F2 |Breakpoint|
        |F9 |Run|
        |CTRL+F2 |Restart|
        |F7 |Step into|
        |F8 |Step over|
        |CTRL+G|Go to memory location|


    ??? info "Dynamic Analysis of x86"

        #### Debugging the Dropper: Dynamic Analysis of x86 Instructions & API Calls

        load the sample in x32dbg and run the program
        Keep hitting F8 until it hangs for a bit somewhere, that's where we start tracing

        On that hang point, set a breakpoint using F2

        We can also right-click > Follow in Disassembler > choose the location

        ![img](/Knowledge_Base/images/PMA-micro-s9a8s-0.png)

        If we followed it, it will show the following. You can see a call to the Windows API <mark>InternetOpenW</mark>

        We can also see the user agent being utilized for the Windows API call for InternetOpenW

        ![img](/Knowledge_Base/images/PMA-micro-s9a8s-2.png)

        We can do side by side Analysis, load up Cutter and open the same sample.

        Locate the same API aall and set them side by side to compare
        
        ![img](/Knowledge_Base/images/PMA-micro-s9a8s-1.png)

        Make sure inetsim is running and then open up Wireshark to run a capture.

        F7 step into the push one by one until we get to the actual API call and Wireshark is capturing any activity on the side.

        ![img](/Knowledge_Base/images/PMA-micro-s9a8s-3.png)

        ![img](/Knowledge_Base/images/PMA-micro-s9a8s-4.png)

        When the program jumps into the actual call it will process the actual call, keep going until it gets out.

        Keep doing this until the next call and so on...

        After the download API we see ```test eax,eax```, this is basically comparing eax to itself to see if the result is zero, we can see EAX is `00000000` therefor the ZF flag is set to 1.

        All of this is to confirm if the returned value of the download was good
        
        ![img](/Knowledge_Base/images/PMA-micro-s9a8s-5.png)

        Next is jne [jump if not zero], in this case the ZF is 1 so it won't go into that portion. If we want to see what the jne does, we can manually change the ZF value from `1` to `0`
        
        ![img](/Knowledge_Base/images/PMA-micro-s9a8s-6.png)

        We reached a ShellExecute, now we can open procmon at the same time and filter for DownloadFromURL and step in and see what's going on

        ![img](/Knowledge_Base/images/PMA-micro-s9a8s-7.png)

        F8 until we get the Download File call, locate the file on the file system

        ![img](/Knowledge_Base/images/PMA-micro-s9a8s-8.png)



    ??? info "Under a Microscope"

        #### Hello, World! Under a Microscope Part II

        Another way of starting the debugging is by loading the sample into cutter and getting the memory address of the main function so then we can use that to start with in x32dbg

        Cutter main function memory location

        ![img](/Knowledge_Base/images/PMA-micro-s9a8s-9.png)

        x32dbg start with memory location

        In x32dbg CTRL+G and paste the memory location then click OK

        ![img](/Knowledge_Base/images/PMA-micro-s9a8s-10.png)

        Now we are at the main function, we then set a breakpoint to the memory location and the printf

        ![img](/Knowledge_Base/images/PMA-micro-s9a8s-11.png)

        Start with F9 and hit it until you get to the breakpoint.

        So because it's located in memory we can watch our registers as the instructions take place. If you follow in Disassembler you will be brought to the instruction point where we return after this functions returns

        ![img](/Knowledge_Base/images/PMA-micro-s9a8s-13.png)

        x32dbg anywhere there is an instruction that will act on one of the registers the debugger will highlight that for us

        ![img](/Knowledge_Base/images/PMA-micro-s9a8s-12.png)

        ![img](/Knowledge_Base/images/PMA-micro-s9a8s-14.png)

        Move the value to esp, but before it moved we can actually edit the value being sent over
        
        ![img](/Knowledge_Base/images/PMA-micro-s9a8s-16.png)

        To edit what's being printed out, we need to know how many bytes we are changing. In this case "Hello, World!" is 13 Bytes
        
        ![img](/Knowledge_Base/images/PMA-micro-s9a8s-15.png)



!!! info ""

    ### SikoMode

    [SikoMode Lab](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs/2-3.Challenge-SikoMode)




!!! info ""

    ### Binary Patching & Anti-analysis


    ??? info "Setting Up"

        #### Setting Up

        Make a copy of the binary and open it in cutter "Load in write mode"

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-1.png)

        open the main() function in the Decompiler panel

        Now we need to find a way of tricking the Malware, so in case of a function that calls to exit if cannot reach a website or check something. We can change the jne (jump if not equal) instruction to je (jump if equal), then we save it as a new binary to run.

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-2.png)



    ??? info "Anti-analysis Techniques"

        #### Identifying & Defeating Anti-analysis Techniques

        [simpleAntiAnalysis Lab](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs/2-5.AntiAnalysis/1.simpleAntiAnalysis)

        All of these techniques belong to the Defense Evasion tactic:

        - [Virtualization/Sandbox Evasion](https://attack.mitre.org/techniques/T1497/)
        - [Debugger Evasion](https://attack.mitre.org/techniques/T1622/)
        - [Execution Guardrails](https://attack.mitre.org/techniques/T1480/)



!!! info ""

    ### Gone Phishing: Maldoc Analysis

    ??? info "OLEdump"

        #### Analyzing Excel Maldocs: OLEdump

        [Gone Phishing Excel Lab](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs/3-1.GonePhishing-MaldocAnalysis/Excel)

        We can just use Remnux for this one

        ```bash
        #unzip the excel sheet
        unzip xxxx.xlsm
        ```

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-24.png)

        ```bash
        cd xl
        cat vbaProject.bin
        #now we will get teh raw bits for this bin

        #we can use oledump.py for this
        oledump.py xxxx.xlsm
        ```

        The As are indexes of data streams that were identified by oledump
        The M is Macro inside that data stream
        
        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-25.png)

        Now we can choose one of those Indexes that we want to dig in

        ```bash
        oledump.py -s 3 xxx.xlsm
        ```

        This will show us the HEXDump

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-26.png)

        ```bash
        #Instead to make it easier, we will do capital S for Strings
        oledump.py -s 3 -S xxx.xlsm
        ```

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-27.png)

        ```bash
        #Attempt to recover the Macro
        oledump.py -s 3 --vbadecompresscorrupt xxx.xlsm
        ```

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-28.png)


    ??? info "Remote Template Macro Injection"

        #### Analyzing Word Maldocs: Remote Template Macro Injection

        [Gone Phishing Word Lab](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs/3-1.GonePhishing-MaldocAnalysis/Word)

        docm > Macro enabled document
        docx > Can contain Macros

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-29.png)

        ```bash
        oledump.py xxx.docm
        ```

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-30.png)

        This sample has the same vba in the excel example, so from here on now is the same as the previous example.

        The rels is something you will find in polished documents

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-31.png)

        What this file looks like

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-32.png)

        The document when it loads, it will go to the link to download the polished document. You can put a link to a Macro and once it pull sit, it will execute it.

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-33.png)

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-34.png)


!!! info ""

    ### What The Shell? Shellcode Analysis

    ??? info "Carving Shellcode & scdbg"

        #### Analyzing Shellcode: Carving Shellcode & scdbg

        [Carve from text Lab](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs/3-2.WhatTheShell-ShellcodeAnalysis/CarveFromText)

        Note: scdbg is available [Here](https://github.com/dzzie/VS_LIBEMU/releases/download/12.7.22/VS_LIBEMU_12_7_22.zip) if it is not installed in FLARE-VM 

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-35.png)

        0xfc
        in C# 0x denotes a Hex Bytes, the following 2 alpha numeric characters represented for the Hex Bytes (the actual data of the Hex Byte)

        We will extract that value from the original C# code and put it into a txt file.
        
        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-36.png)

        We will create a Python carver to clean up the txt file Hex, name it `carver.py`

        ```python
        #python carver
        #!/user/bin/env python3
        with open("xx.txt","r") as f:
                hex_string = f.read().replace("0x","").replace("byte[] rsrc = new byte[464] {","").replace(" };","").replace(",","")
                hex_encode = hex_string.encode()
        print(hex_string)
        print(hex_encode)
        ```

        we can test this out `python3 carver.py` check the results, if looks good we will get back to make some updates to our script


        ```python
        #python carver
        #!/user/bin/env python3
        with open("xx.txt","r") as f:
                hex_string = f.read().replace("0x","").replace("byte[] rsrc = new byte[464] {","").replace(" };","").replace(",","")
                hex_encode = hex_string.encode()
        
        with open ("out.bin","wb") as out
            out.write(hex_encode)
        ```

        `python3 carver.py`

        `cat out.bin`

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-37.png)

        We will now move this out.bin to FLare-vm

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-38.png)

        ```powershell
        #we will use shell code debug
        scdbg /f out.bin -s -1
        ```
        
        `scdbg` will resolve all steps without running the malware sample

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-39.png)

        We can see what it's calling

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-40.png)


    ??? info "Memory Shellcode"

        #### Carving Shellcode from Memory

        [Carving from Memory Lab](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs/3-2.WhatTheShell-ShellcodeAnalysis/CarveFromMemory)

        Addendum: Find the exact size of the shellcode
        If I'm feeling lazy, I will usually copy contiguous bytes from memory until I hit a bunch of null bytes (\x00), which is usually good enough. However, there are more scientific ways to get the exact size of the shellcode so we know exactly how much we need to copy out of memory.

        In this example, the size of the buffer that the program is injecting is known and used elsewhere during the injection routine. For example, the VirtualAllocEx call is executed before the WriteProcessMemoryEx call. VirtualAllocEx sets up the section of memory and changes the RWX permissions so the shellcode is executable.

        According to the documentation, VirtualAllocEx takes in four parameters. The third parameter is the dwSize parameter, which is the size of the buffer in bytes:

        > [in] dwSize: `The size of the region of memory to allocate, in bytes.`

        If we locate the VirtualAllocEx call, which is right before WriteProcessMemory, and set a breakpoint on the third parameter that is moved into the registers before it is called, we see that it moves a value from RDX into R8 to set up for that call. If we look at RDX when the move takes place, it's the hex value `0x01D1`, which corresponds to the decimal value 465, so we know the shellcode is 465 bytes. Then, do some memory address hex math and you know where to start and where to end.

        If we load the sample into `pestudio` we will see the Win API Calls, we want to debug just before it writes to memory.

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-41.png)

        Load the sample int `Cutter`, we can see that we do not have any Debug symbols, so this is going to make it a bit harder to analyze.

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-42.png)

        What we can do, is start from the end of the program, find the last place a function returned something into the `EAX`

        enterypoint => CRT (preamble to run this program) => main
        - so what this means, when the program runs, the entrypoint is the first thing calls, however, it isn't the main function.
        - The entrypoint sets up the CRT - C Run Time, in CRT the last thing that happens is a call to the main function.
        - If we do this in reverse, the last thing that was called, is going to return from main function into the CRT.
        - SO basically, we need to look al the last thing that was called into CRT.

        So now we will load the `graph` view and go all the way to the bottom and start from there

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-43.png)

        Check the `EAX` dword value that was called, click on the value so it would highlight all the places this value was used

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-44.png)

        Looks like last time it was called it was in this section (3rd from bottom). Just before that we see a `call` function, that function returns the value that will be used in `EAX`.  There is a chance that this is the actual `main` function. Double click on that call

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-45.png)

        Now we are in that function
        
        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-46.png)

        Lets rename the function, right click > `Re-type Local Variable`

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-47.png)

        Name it main and click ok

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-48.png)

        We will start with the last call in `main`, double click it to load the function

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-49.png)

        If we then scroll down and look at the call, we will see the Win API Calls

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-51.png)

        Now since we know which calls are being made through `cutter`, we can just take the memory location for the function. The one we want to dig in, will be the `WriteProcessMemory`

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-52.png)

        Now open the sample in `x64dbg', navigate to the CPU section and `CTRL + G` then paste the memory value


        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-53.png)

        Click F2 to set a breakpoint on the `WriteProcessMemory` Win API Call

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-54.png)

        If we check what the API documentation, we can see what it takes and what it outputs

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-56.png)

        The one we are intrested in is the `lpBuffer`, this is where the Malware is trying to inject itself into

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-55.png)

        Set the breakpoint on the call itself now

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-57.png)

        If we actually look back to see the parameters passed to the API, we can see the lpBuffer value is the `r8,rcx`

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-58.png)

        Right click the lpBuffer value `r8,rcx` > Follow in Dump > select the r8

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-59.png)

        We can see the shell Bytes

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-60.png)

        Highlight all the shell Bytes > right click > Binary > Save To a File
        
        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-61.png)


        Save it to dump.bin

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-62.png)

        We can now open a Hex Editor like `HxD` then load the Binary into it

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-63.png)

        The better tool to use would be shell code debug `scdbg`, open a shell session and type the following

        ```powershell
        scdbg /f .\dump.bin /s -1 
        ```

        Now we can see all the Win API Calls

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-64.png)


!!! info ""

    ### Off-Script: Scripted Malware Delivery Mechanisms


    ??? info "PowerShell"

        #### PowerShell: Analyzing Obfuscated Scripts

        [PowerShell Lab](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs/3-3.OffScript-ScriptMalware/PowerShell)


        **Powershell** is an interpreter for the .Net Framework

        Arm the sample and loaded it in vsCode > `ALT + Z` to word wrap

        So this sample is converting Base64 into a String, it then will decompress the String. The output will then be passed into the 2nd phase of Encoding to ACII
        
        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-65.png)

        So lets defang the sample by taking out the Invoke Expression `iEx(` and the last bracket `)`, now we can assign the remianing to a variable

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-68.png)

        Open a shell session and declare your variable `$megasus = ` then paste the value you copied previously, the defanged script

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-69.png)

        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-70.png)

        So instead of Invoking the expression and have it do its thing, we will do the following

        ```powershell
        write-host $megasus
        #hit enter
        ```

        Now we can see the Malware script wihtout detonating it, so it decoded and deinflated the sample by doing that.
        
        ![img](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-71.png)


    ??? info "VBScript"

        #### VBScript: Analyzing a Multi-Stage MSBuild Dropper

        [VBScript Lab](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs/3-3.OffScript-ScriptMalware/VBScript)

        The script will decode both cert files and send them to a location, the output files are one.vbs & xml.xml, it will then wait 100 ms and will run one.vbs afterwards.
        
        ![img](/Knowledge_Base/images/HTA-img-0s9ujsj-0.png)

        If we read the code we will see that it's replacing all vVv with nothing ""

        ![img](/Knowledge_Base/images/HTA-img-0s9ujsj-2.png)

        If we do that, now we see what's going on. The GetObject here contains a COM Class (Component Model Object). COM is one of the most abusable features of the Windows OS.
        
        This COM is invoking ShellBrowserWindow to run a Shell command, it will do in a hiden window `that's the 0 value` and it will try to `runas` Administrator and will run the contents of the `xml.xml`

        ![img](/Knowledge_Base/images/HTA-img-0s9ujsj-1.png)

        We can run the sample to see what it's doing, well in the first run since we didn't run as Admin, nothing happened

        ![img](/Knowledge_Base/images/HTA-img-0s9ujsj-3.png)

        Lets see what happens if we run it as Admin.
        Creating adding a user to the remote desktop User Group, adding that user to the Administrator's Group then opening up a port on the Firewall to open RDP if not already open up.

        ![img](/Knowledge_Base/images/HTA-img-0s9ujsj-4.png)

        All of that is obfuscated in this Hex

        ![img](/Knowledge_Base/images/HTA-img-0s9ujsj-5.png)

        The user is `wdsadmin`
        
        ![img](/Knowledge_Base/images/HTA-img-0s9ujsj-6.png)

        ![img](/Knowledge_Base/images/HTA-img-0s9ujsj-7.png)


    ??? info "HTML Applications (HTA)"

        #### HTML Applications (HTA): Wrapped Payloads, Scripted Delivery, & WMI

		[Lab File(s)](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs/3-3.OffScript-ScriptMalware/HTA/Dropper.hta.7z)

		??? info "Introduction"

			#### Introduction

			On the subject of scripted malware delivery mechanisms, let’s examine a curious class of malware called the HTML Application (HTA) file. HTAs are commonly used as the payload of phishing attacks. By the end of this section, you’ll see why this is the case.

			Extract the sample and let’s get going!

		??? info "The Offensive Potential of HTML"

			#### The Offensive Potential of HTML

			It is no secret that HTML can be weaponized. Every time you visit a website, your web browser downloads and renders the code that is served out by that website. Your browser is really just an interpreter for the technologies that power the web: HTML, CSS, and JavaScript.

			HTML provides the structure of the website. CSS applies color, fonts, presentation, and layouts of the website. And JavaScript can dynamically control behavior of elements of the website.

			It’s that last one that we need to watch out for.

		??? info "JavaScript Is Dangerous"

			#### JavaScript Is Dangerous

			You may be familiar with the classic Cross-Site Scripting test that pops an alert box by injecting the `<script>` block into an HTML page. If you’ve seen this test before, you may have wondered “what is actually going on when this happens?”

			![img](/Knowledge_Base/images/HTA-img-0s9ujsj-8.png)

			HTML pages can define the `<script>` tag to include code that can run different scripting languages. In most cases, the language is JavaScript. JavaScript can execute code within the browser to move components around on the page, change colors and fonts, pop that alert box, and do many other functions. Think of JavaScript as the programmatic engine of HTML.

			The [W3 Schools demo for JavaScript’s alert() box method](https://www.w3schools.com/jsref/met_win_alert.asp) demonstrates this well.

			Try saving this code to `index.html` and running it locally by opening it in a web browser

			```js
			<!DOCTYPE html>
			<html>
			<body>

			<h1>The Window Object</h1>
			<h2>The alert() Method</h2>

			<p>Click the button to display an alert box.</p>

			<button onclick="myFunction()">Try it</button>

			<script>
			function myFunction() {
			alert("Hello! I am an alert box!");
			}
			</script>

			</body>
			</html>
			```

			The takeaway here is that **JavaScript executes code within the browser**. But when JavaScript executes within a web browser, the code execution is confined to the web browser itself. That is to say, the code runs in the context of the browser, manipulates the document model of the web page, and can manipulate cookies, but can’t reach the operating system of the host unless there is some kind of browser based code execution vulnerability.

			When used in an offensive capacity, JavaScript can perform activities like hooking the client’s browser (see the [BeEF Framework](https://beefproject.com/) for an example of this) and downloading files via [HTML Smuggling](https://attack.mitre.org/techniques/T1027/006/). The offensive potential of JavaScript is apparent, but if it’s usually limited to the browser of the victim, then that doesn’t sound so bad, right?

			Wrong!

		??? info "Enter, HTML Applications"

			#### Enter, HTML Applications

			Imagine that a developer needs to design a compact, portable HTML site that can be easily sent to anyone who needs it. Maybe it’s a company survey. Maybe it’s a presentation of some sort. The developer can create an HTML Application (HTA) file for this purpose.

			HTAs are Windows-executable, packaged HTML files that run HTML, CSS, and Windows native scripting languages from a single file outside of the context of the web browser. The last part of that sentence is the really scary thing here: **HTAs do not run in the context of the Windows web browser, but instead run as a trusted application on the operating system**.

			An HTML Application is not much different from a normal HTML page in terms of construction. In fact, you can use the exact same code from an HTML page to make an HTA.

			Try it out yourself — take the W3 Schools code for the JavaScript alert() method that we just used, open a new text file, write that HTML code into the file, and save it as `test.hta` on your FLARE-VM host. Then, double click on the file

			![img](/Knowledge_Base/images/HTA-img-0s9ujsj-9.png)

			The window that spawns is a self contained Windows application that renders and runs the HTML, CSS, and/or scripting code that is packaged inside of it. If we click on the Try it button, we see that this application can execute the embedded JavaScript code

			![img](/Knowledge_Base/images/HTA-img-0s9ujsj-10.png)

			The scripting languages we can use here are not limited to JavaScript (or JScript in the context of Windows). We can embed any Windows-native scripting language inside of an HTA and it will execute the provided code. This includes JavaScript/JScript, VBScript, and both together in the same file.

			In the previous section, we saw how VBScript can be weaponized. So the thought of a self contained HTML application that can execute code dynamically and have it run on the operating system of the victim should spark our concern.

		??? info "Analyzing HTAs"

			#### Analyzing HTAs

			Let’s examine a weaponized HTA and unravel its functionality to demonstrate how to analyze these files.

			The sample archive is called `Dropper.hta.malz`. Let’s rename this to `Dropper.hta`. When we do this, notice that Windows changes the file icon to an application icon

			![img](/Knowledge_Base/images/HTA-img-0s9ujsj-11.png)

		??? info "Static Analysis"

			#### Static Analysis

			Recall that an HTA is still, under the hood, HTML in a single file. Let’s open this file in Visual Studio Code to examine the HTML located within it:

			```js
			<html>
			<head>
			<title></title>
			<body>
			<script language="JavaScript" type="text/javascript">
			document.write(unescape('%3c%68%74%6d%6c....[snip]......'));
			</script>
			</body>
			</html>
			```

			Take note of the contents of this file. The actual HTML of the application is barren but has one notable feature. The `<script>` tag wraps a call to the JavaScript `document.write()` method. This call to `document.write()` has a block of characters that are delimited by percent signs inside of the `unescape()` method. Let’s examine both methods to identify what they do:

				- `document.write()`: The `write()` method writes directly to an open (HTML) document stream.
				- `unescape()`: The `unescape()` function computes a new string in which hexadecimal escape sequences are replaced with the characters that they represent.


			Immediately, we have an idea of what’s going on here:

				- The block of characters inside the `unescape()` method is a bunch of hexadecimal bytes that are interpreted and replaced by the character that they represent.
				- Then, the interpreted characters are written to the document of the page.

			We can decode the block of hex characters in CyberChef by using the `From Hex` item and delimiting by percent sign. FLARE-VM installs a local instance of CyberChef in the `C:\Tools\cyberchef directory`. An online instance of CyberChef is also running at the following link [CyberChef](https://gchq.github.io/CyberChef/)

			Using CyberChef, we add the `From Hex` decoder and change the delimiter to `Percent`. Then, we copy the block of hex bytes into the Input section:

			![img](/Knowledge_Base/images/HTA-img-0s9ujsj-12.png)

			The Output section now contains the following

			![img](/Knowledge_Base/images/HTA-img-0s9ujsj-13.png)

			Several things are concerning about this!

			When the HTA is executed, it decodes and writes this HTML to the page. This block of HTML contains another script block that invokes VBScript to run code. But what does the code do?

		??? info "Invoking WMI & Executing PowerShell"

			#### Invoking WMI & Executing PowerShell

			The VBScript code starts by setting up the required parameters to invoke Windows Management Instrumentation (WMI) to execute a process. WMI is a part of the Windows operating system that acts as an interface for management purposes. It is extremely powerful and complicated and most of its functionality is outside the scope of this course, but it can do a few things that make it relevant for malware analysis.

			WMI can start and run processes through the Win32_Process namespace. Effectively, this means that anything that can access WMI can execute a process.

			In our sample, the VBScript code is setting WMI up to be able to execute a process

			![img](/Knowledge_Base/images/HTA-img-0s9ujsj-14.png)

			The VBScript then performs the following

			![img](/Knowledge_Base/images/HTA-img-0s9ujsj-15.png)

			This line executes a process through the WMI service and returns the results to the `Error` variable.

			The process argument here runs a command shell which, in turn, runs PowerShell in a hidden window. When PowerShell is executed, it performs the following

			![img](/Knowledge_Base/images/HTA-img-0s9ujsj-16.png)

			The VBScript then calls `window.close()` to close out of the HTA window.

			If we take a step back, we now have a clear idea of the execution chain here:

				- HTA is opened and runs the embedded JavaScript.
				- The JavaScript decodes the hex bytes of an inner HTML document and writes it into the HTA.
				- The inner HTML document invokes VBScript to execute WMI.
				- WMI runs a process to call a command shell.
				- The command shell, in turn, runs PowerShell in a hidden window.
				- PowerShell runs a download cradle command to reach out to `http://tailofawhale.local/TellAndSentFor.exe`, write it to the %temp% directory as jLoader.exe and then execute `jLoader.exe`.

			With a good understanding of the payload, let’s move onto dynamic analysis to see it in action!

		??? info "Dynamic Analysis"

			#### Dynamic Analysis

			When we open the HTA program, a window flashes for a moment and then disappears. If we are running INetSim at the time of detonation, we see the default INetSim binary spawn. Take note of the location where the binary is running from

			![img](/Knowledge_Base/images/HTA-img-0s9ujsj-17.png)

			Dropper.hta has clearly succeeded in downloading and executing something. Let’s examine the network signatures.

			In Wireshark, we see the outbound DNS request for `tailofawhale.local` and its DNS resolution

			![img](/Knowledge_Base/images/HTA-img-0s9ujsj-18.png)

			We can also see the HTTP request to the malicious domain and response in Wireshark

			![img](/Knowledge_Base/images/HTA-img-0s9ujsj-19.png)

			If we go to examine host-based indicators, we run into a small snag. There is no process called “Dropper.hta” anywhere in the list of running processes on the host. Where does this process execute?

			HTAs do not execute directly. When double-clicked, they are passed to the native Windows binary `mshta.exe` which executes them on its behalf. `mshta.exe` acts as an HTML interpreter and loads the HTML from the HTA along with any DLLs that deal with script execution and then executes the program all at once.

			If we look in the Procmon process tree after detonation, we see an invocation of `mshta.exe` that takes the path to our HTA sample as its argument

			![img](/Knowledge_Base/images/HTA-img-0s9ujsj-20.png)

			![img](/Knowledge_Base/images/HTA-img-0s9ujsj-21.png)

			We’ve accounted for the execution of the HTA, but we haven’t accounted for the other parts of the payload yet. Where is the call to PowerShell and the command shell?

			Higher up in the process list, there is an instance of svchost.exe that is executing a process called wmiprvse.exe. This is the way that Windows invokes WMI to execute processes

			![img](/Knowledge_Base/images/HTA-img-0s9ujsj-22.png)


			We can follow the `wmiprvse.exe` process all the way down through the call to PowerShell and, eventually, the execution of the `jLoader.exe` program. In this case, this was our INetSim default binary that spawned the message box, but in real life this is likely a second stage payload.

			After annotating these details, we have effectively analyzed the HTA dropper sample.

		??? info "Summary"

			#### Summary

			This section covered the analysis methodology of the HTA, a curious little file format that wraps all of the functionality of HTML into a single file and executes it directly on the Windows OS. It also covered a bit about how WMI can execute processes.










!!! info ""

    ### Reversing C# Malware

    ??? info "Reversing C# & the .NET Framework"

        #### Intro to Reversing C# & the .NET Framework

        [Lab File(s)](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs/3-4.StaySharp-CSharpMalware/Malware.cryptlib64.dll.malz/Malware.cryptlib64.dll.malz.7z)

        Floss the sample > we see mscorlib so it's C#, also another clue is the .NETFramework version

        **How Does C# Code Get Compiled and Executed?**

        ![alt text](PMA-img-s98nsxz-0.png)

        - **Compiling C# Code**
          - Once the code is written, it needs to be compiled into MSIL code using the C# compiler.
          - This creates an assembly that contains the compiled code and any metadata that describes the code.
        - **Loading the Assembly**
          - The assembly is loaded into the CLR, which loads the code into memory and performs a number of checks to ensure that the code is safe to execute.
          - This includes verifying that the code has not been tampered with and that it is signed with a valid digital signature.
        - **JIT Compilation**
          - The MSIL code is then compiled by the Just-In-Time (JIT) compiler into native machine code that can be executed on the computer’s processor.
          - This code is generated dynamically at runtime and is optimized for the specific hardware and operating system on which it is running.
        - **Execution**
          - The native machine code can now be executed by the computer’s processor, which runs the C# application.
          - During execution, the CLR manages the memory and resources used by the application, including performing garbage collection to free up memory that is no longer being used.

        
        Language C#
        C# Compiler translate language to IL > so compiles into an Assembly such as .exe
        IL (Intermediate Language) Creation
        CLR (Common Language Runtime) This is how a C# program is execution
        OS


    ??? info "Reversing an Encrypted C2 Dropper"

        #### Reversing an Encrypted C2 Dropper DLL with dnSpy

        [Lab File(s)](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs/3-4.StaySharp-CSharpMalware/Malware.cryptlib64.dll.malz/Malware.cryptlib64.dll.malz.7z)

        !!! warning ""

            **Errata**
            Note: dnSpy is available at the following [GitHub repository](https://github.com/dnSpy/dnSpy/releases/download/v6.1.8/dnSpy-net-win64.zip)

            <mark>Note</mark> The tool I use at the 12:15 mark is **Fakenet-NG**, which is a built-in network simulator on FLARE-VM. It is basically the same as INetSim, but runs on the FLARE-VM host instead of on REMnux. I left it out of the course because it tends to be very buggy and mess up the networking stack on the FLARE-VM host, but it helps to set up a quick network simulator on FLARE-VM.

            The important part is that it catches the callback domain name for this C2 dropper, which can also be identified with INetSim.

        load the sample into dnSpy

        ![alt text](/Knowledge_Base/images/PMA-img-s98nsxz-1.png)

        dnSpy will reassemble the binary code. In this sample it seems when the program was compiled it was named `EmbedDLL`

        ![alt text](/Knowledge_Base/images/PMA-img-s98nsxz-2.png)

        This program loads up a base64 into memory which it will decrypt with provided password, it will also end up with creating a registry file

        ![alt text](/Knowledge_Base/images/PMA-img-s98nsxz-5.png)

        **How to run dlls?**

        In order to run a dll you need to know the functions it has defined so you can call the dll and its function, in this case the function is called `embed`

        ![alt text](/Knowledge_Base/images/PMA-img-s98nsxz-3.png)

        ```bash
        rundll32 <sample_dll>,<function>
        ```

        ![alt text](/Knowledge_Base/images/PMA-img-s98nsxz-4.png)

        If we check the location of the files as stated in the code we will see them

        ![alt text](/Knowledge_Base/images/PMA-img-s98nsxz-6.png)

        ![alt text](/Knowledge_Base/images/PMA-img-s98nsxz-7.png)

        Check registry as well

        ![alt text](/Knowledge_Base/images/PMA-img-s98nsxz-8.png)

        So the registry is calling to the VBS script which is calling the xml script, it's runs when someone logs in

        ![alt text](/Knowledge_Base/images/PMA-img-s98nsxz-11.png)

        Checking the XML

        ![alt text](/Knowledge_Base/images/PMA-img-s98nsxz-9.png)

        Seems to be using an Evasion Technique by loading Reflection Assembly

        ![alt text](/Knowledge_Base/images/PMA-img-s98nsxz-10.png)

        If we run the VBScript we will see the DNS call in `fakenet.exe`
        
        ![alt text](/Knowledge_Base/images/PMA-img-s98nsxz-12.png)


!!! info ""

    ### Analyzing Go Malware

    ??? info "Programming Language"

        #### Programming Language Recognition & Analyzing a Go Service Backdoor

        !!! info ""
            
            [Lab File(s)](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs/3-5.GoTime-GoMalware/Backdoor.srvupdat.exe.malz.7z)

            **References**

            - [**Unit42 The Gopher**](https://unit42.paloaltonetworks.com/the-gopher-in-the-room-analysis-of-golang-malware-in-the-wild/)
            - [Merlin C2 Agent written in Go](https://github.com/Ne0nd0g/merlin)

        Notice that the binary size for `Go` is huge, almost 7MB for about 20 lines of code

        ![alt text](/Knowledge_Base/images/PMA-img-s98nsxz-14.png)
        
        floss the sample

        ![alt text](/Knowledge_Base/images/PMA-img-s98nsxz-13.png)

        ![alt text](/Knowledge_Base/images/PMA-img-s98nsxz-15.png)

        We can also try something like this

        ![alt text](/Knowledge_Base/images/PMA-img-s98nsxz-16.png)

        References for golang

        ![alt text](/Knowledge_Base/images/PMA-img-s98nsxz-17.png)

        ![alt text](/Knowledge_Base/images/PMA-img-s98nsxz-18.png)

        .symtab showed up when loading the sample into PEbear

        ![alt text](/Knowledge_Base/images/PMA-img-s98nsxz-19.png)


!!! info ""

    ### Mobile Malware Analysis

    ??? info "Lab Update: Installing MobSF"

        #### Lab Update: Installing MobSF

        [MobSF Docker Install Instructions](https://mobsf.github.io/docs/#/docker)

        In order for us to install the tool we need, we need to change the Network to NAT on the Remnux vm then reboot the vm.

        Installing MobSF on docker, we won't be able to do Dynamic Analysis but we can do Static Analysis

        ```shell
        docker pull opensecurity/mobile-security-framework-mobsf
        docker run -it --rm -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
        ```

        Now after install is completed, we need to switch back the Network adapter on the vm to `Host-only Adapter` then reboot the vm.

        execute this

        ```shell
        docker run -it --rm -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
        ```

        ![alt text](/Knowledge_Base/images/PMA-img-s98nsxz-20.png)

        You should be able to use it now.


    ??? info "MobSF"

        ####   Intro to MobSF

        !!! info ""
            
            [Lab File(s)](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs/3-6.Mobile-Malware/Android/Malware.android.apk.malz.7z)

            Update 11/13/21: A few weeks after the release of this course, [Aaron Wilson](https://www.linkedin.com/in/wilson-security/) released the [Mobile Application Penetration Testing](https://academy.tcm-sec.com/courses/mobile-pentesting?affcode=770707_i1eilqya) course here at TCM Academy. While this part of the course scratches the surface of reverse engineering Android applications, Aaron's course is a full, in-depth look at mobile application pentester methodology. The skill overlap between RE and pentesting mobile applications is significant, so check his course out if you're hungry for more mobile app security!

            (Aaron's affiliate link is used in the hyperlink above for full disclosure. I make nothing off the purchase of the course, I'm simply a big fan of what he's put together!)

        ![alt text](/Knowledge_Base/images/PMA-img-s98nsxz-21.png)

        Rename the sample to APK then upload it

        ![alt text](/Knowledge_Base/images/PMA-img-s98nsxz-22.png)

        We can see the Java source code

        ![alt text](/Knowledge_Base/images/PMA-img-s98nsxz-23.png)

        ![alt text](/Knowledge_Base/images/PMA-img-s98nsxz-24.png)

        ![alt text](/Knowledge_Base/images/PMA-img-s98nsxz-25.png)

        ![alt text](/Knowledge_Base/images/PMA-img-s98nsxz-26.png)

        ![alt text](/Knowledge_Base/images/PMA-img-s98nsxz-27.png)


!!! info ""

    ### Analyzing Real-World Malware Samples

    ??? info "WannaCry.exe"

        #### WannaCry.exe Introduction & Walkthrough

        [Lab File(s)](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs/4-1.Bossfight-wannacry.exe/Ransomware.wannacry.exe.malz.7z)

        [GhidraNinja: Reversing Wannacry Part 1](https://www.youtube.com/watch?v=Sv8yu12y5zM)

        ??? info "floss"

            ![alt text](/Knowledge_Base/images/pma-img-8y9sh-s7hu-0.png)

            We see the DOS message multiple times which could indicate multiple excutables, multiple stages. We also see a lot of API calls

            ![alt text](/Knowledge_Base/images/pma-img-8y9sh-s7hu-1.png)

            ![alt text](/Knowledge_Base/images/pma-img-8y9sh-s7hu-2.png)

            ![alt text](/Knowledge_Base/images/pma-img-8y9sh-s7hu-3.png)

            ![alt text](/Knowledge_Base/images/pma-img-8y9sh-s7hu-4.png)


        ??? info "PEStudio"

            ![alt text](/Knowledge_Base/images/pma-img-8y9sh-s7hu-5.png)            

            ![alt text](/Knowledge_Base/images/pma-img-8y9sh-s7hu-6.png)

            ![alt text](/Knowledge_Base/images/pma-img-8y9sh-s7hu-7.png)


        ??? info "INetSim"

            So if we have INetSim running and trying to get a packet capture going we will see that the url is gets a `200 ok`, it will stop executing the malware.

            So for our case we will need to have INetSim (disabled/not running) and we can use some of the other local tools

        ??? info "TCPView"

            We will see the APIPA address being called, which isn't really pointing anywhere. APIPA [Automatic Private IP Addressing] range is [169.254.0.0 TO 169.254.255.255].

            The port it's trying however is the SMB port of 445. ALso it's seems to be trying different IPs on the Network to spread itself (has worm capabilities)

            ![alt text](/Knowledge_Base/images/pma-img-8y9sh-s7hu-8.png)

            Attempting to open a listener on port `9050`

            ![alt text](/Knowledge_Base/images/pma-img-8y9sh-s7hu-9.png)

        ??? info "Procmon"

            Host indicators

            setup thefilters
            
            ![alt text](/Knowledge_Base/images/pma-img-8y9sh-s7hu-10.png)

            Run the binary as admin and see what happens

            ![alt text](/Knowledge_Base/images/pma-img-8y9sh-s7hu-12.png)

            We find some task scheduler activities going on

            ![alt text](/Knowledge_Base/images/pma-img-8y9sh-s7hu-13.png)

            Process tree 

            ![alt text](/Knowledge_Base/images/pma-img-8y9sh-s7hu-15.png)

            So we know the parent PID is `3336`, we can filter on that as Parent PID

            ![alt text](/Knowledge_Base/images/pma-img-8y9sh-s7hu-14.png)

            We see the beginning of the exection of second stage

            ![alt text](/Knowledge_Base/images/pma-img-8y9sh-s7hu-18.png)

            Filter for `Operation` `CreateFile`

            ![alt text](/Knowledge_Base/images/pma-img-8y9sh-s7hu-17.png)

            We see that it's creating a directory in `c:\ProgramData\`
            
            ![alt text](/Knowledge_Base/images/pma-img-8y9sh-s7hu-19.png)

            The staging area

            ![alt text](/Knowledge_Base/images/pma-img-8y9sh-s7hu-20.png)

            We see a service created with the same name as the weird folder name. So this will be the service that will re-encrypt everything once you restart your computer

            ![alt text](/Knowledge_Base/images/pma-img-8y9sh-s7hu-21.png)


        ??? info "Cutter"

            ![alt text](/Knowledge_Base/images/pma-img-8y9sh-s7hu-23.png)

            ![alt text](/Knowledge_Base/images/pma-img-8y9sh-s7hu-22.png)

            ![alt text](/Knowledge_Base/images/pma-img-8y9sh-s7hu-24.png)

        ??? info "Debugger x32dbg"

            Search for string reference the url

            ![alt text](/Knowledge_Base/images/pma-img-8y9sh-s7hu-25.png)

            We want to set a breakpoint at that address location (F2)
            
            ![alt text](/Knowledge_Base/images/pma-img-8y9sh-s7hu-26.png)

            Hit F9 until you see the URL

            ![alt text](/Knowledge_Base/images/pma-img-8y9sh-s7hu-27.png)

            We keep stepping over and we see the next call

            ![alt text](/Knowledge_Base/images/pma-img-8y9sh-s7hu-28.png)

            We check the `test edi, edi`, this is teh result of the `InternetOpenUrl` Call. We see that the EDI value isn't cleared out, it's `00CC000C`.

            If we hit `F8` we will see the test result shown in next figure
            
            ![alt text](/Knowledge_Base/images/pma-img-8y9sh-s7hu-29.png)

            So the test result reflected in `ZF` is `0`, which means the flag was cleared due to API call `InternetOpenUrl` returning a result

            ![alt text](/Knowledge_Base/images/pma-img-8y9sh-s7hu-30.png)

            So now the `jne` will evaluate the `ZF` result. If the `ZF` flag is set to `0` take the jump to exit the program, if not then continue to the next Call.

            This is the kill switch that stops the Malware from running.

            ![alt text](/Knowledge_Base/images/pma-img-8y9sh-s7hu-34.png)

            So if we change the `ZF` value to '1', the program will not jump and will insteadcontinue to the next API Call

            ![alt text](/Knowledge_Base/images/pma-img-8y9sh-s7hu-35.png)

            Now we will see that the call was made and the Malware started doing it's file Encryption magic

            ![alt text](/Knowledge_Base/images/pma-img-8y9sh-s7hu-36.png)

            ![alt text](/Knowledge_Base/images/pma-img-8y9sh-s7hu-37.png)


!!! info ""

    ### Automation: Sandboxes & Pipelines

    ??? info "BlueJupyter"

        #### BlueJupyter: Automating Triage with Jupyter Notebooks

        [Lab File(s)](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs/5-1.Automation-BlueJupyter/FORTRIAGE.7z)

        !!! warning ""
        
            <mark>**Note**</mark?> For this section of the course, I am working on my Linux development workstation. This is outside of my lab environment. I confirmed that Blue-Jupyter functions as intended if you install it on REMnux, so feel free to **carefully add REMnux back onto a NAT adapter** and follow the install instructions for Blue-Jupyter.
            
        Update 2/18/22: Dockerized Blue-Jupyter Installation Instructions

        I have Dockerized the [Blue-Jupyter](https://github.com/HuskyHacks/blue-jupyter) application to cut down on the number of poetry and pip errors that were plaguing the code! Please follow these instructions to install and run the Dockerized version of the app. Note that these instructions are different than what you see in the video:

        Clone the PMAT-lab branch of the code repository and change directories into it:

        ```bash
        remnux@remnux:~$ git clone --branch PMAT-lab https://github.com/HuskyHacks/blue-jupyter.git && cd blue-jupyter
        ```

        Run the following Docker build command:

        ```bash
        remnux@remnux:~/blue-jupyter$ sudo docker build -t bluejupyter .
        ```

        When the image is finished building, run the following command to launch the notebook with a published port of 8888 and a mounted volume to the dropbox directory:

        ```bash
        remnux@remnux:~/blue-jupyter$ sudo docker run -it -p 8888:8888 -v /home/remnux/blue-jupyter:/src bluejupyter
        ```

        Now, if you want to add malware to the dropbox, copy it from the PMAT-labs repository into the `/home/remnux/blue-jupyter/malware-analysis/dropbox/` directory and it will also copy into the container.

        You can then proceed to follow the instructions from the video.

        Please note that you need to be connected to the internet and must use a valid VirusTotal API key to get the API results. VirusTotal Public API keys are free and you can sign up for one here [VirusTotal API Key Signup](https://www.virustotal.com/gui/join-us)

        Once you are done, make sure to <mark>**remove REMnux from the NAT adapter**</mark> and double-check that it is back in the isolated lab environment.

        **References**:

        - [Taggart Tech Youtube Channel](https://www.youtube.com/c/TaggartTech)
        - [Taggart Tech Twitch](https://www.twitch.tv/mttaggart)
        - [@MalwareUnicorn](https://twitter.com/malwareunicorn)
        - [Referenced ShellCon talk](https://www.youtube.com/watch?v=rX7lIfQlqOo)
        - [Linux Dev Workstation](https://neon.kde.org/)


    ??? info "Any.Run"

        #### Any.Run: Malware Sandboxing


        Update 11/8/22

        It appears that ANY.RUN now requires you to provide a business email to sign up for an account.

        I will not fault anyone for not wanting to provide a business email for this purpose. Feel free to skip the practical portion of this section and simply watch the video. Alternatively, another sandbox site called [Hatching Triage](https://tria.ge) offers free personal use accounts and does not require a business email. I love Triage and use them for my personal and professional research and recommend their services for this purpose. Please note that their account creation process does take some time due to their verification process. 










    ??? info "ChatGPT Script Analysis"

        #### Advanced Script Analysis with ChatGPT

        [Lab File(s)](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs/5-1.Automation/chatGPT-script-analysis)


!!! info ""

    ### Rule Writing & Report Publishing
    
    ??? info "YARA Rules"

        #### Writing YARA Rules

        [Lab File(s)](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs/5-2.RuleWriting/Malware.yara1.exe.malz.7z)

        [YARA Documentation](https://yara.readthedocs.io/en/stable/)









    ??? info "Detection with YARA"

        #### Detecting Malware with YARA

        [Lab File(s)](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs/5-2.RuleWriting/Malware.yara1.exe.malz.7z)


        **Errata**
        YARA is now invoked with the command `yara64` in the newer version of FLARE-VM. If you can't run YARA by running `yara32`, try `yara64` instead!






    ??? info "Writing & Publishing Analysis Report"

        #### Writing & Publishing a Malware Analysis Report

        [Report Template](https://github.com/HuskyHacks/PMAT-labs/blob/main/labs/5-3.ReportWriting/ReportTemplate.docx)






??? info "Mindmaps"

    #### mindmaps

    ![img](/Knowledge_Base/images/PMA_Summary_20.png)

    ![img](/Knowledge_Base/images/PMA_Summary_21.png)




---


??? info "Extras"

    #### Additional resources

    - SANS Malware Analysis and Reverse-Engineering Cheat Sheet [click to open PDF in new tab](/Knowledge_Base/images/SANS_Malware_Analysis_&_Reverse_Engineering_Cheat_Sheet.pdf)
    - [fareedfauzi](https://fareedfauzi.github.io/2022/08/08/Malware-analysis-cheatsheet.html#ransomware-flow-101)
    - [Malware Analysis - Exploit Notes](https://exploit-notes.hdks.org/exploit/malware/malware-analysis/ )
    - [Malware Static Analysis](https://exploit-notes.hdks.org/exploit/malware/malware-static-analysis/)
    - [Reverse Engineering / Binary Exploitation Cheat Sheet](https://dft.wiki/?p=2587)
    - [Cheatsheet: Windows Malware Analysis and Reversing](https://fareedfauzi.github.io/2022/08/08/Malware-analysis-cheatsheet.html)

