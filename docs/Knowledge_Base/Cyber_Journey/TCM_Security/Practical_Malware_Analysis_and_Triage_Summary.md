!!! info ""

    ### Tools list

    ??? info "FLARE-VM"
        #### FLARE-VM Tool List

        - [strings/FLOSS](https://github.com/mandiant/flare-floss)
        - [PEView](http://wjradburn.com/software/)
        - [upx (not used but referenced)](https://upx.github.io/)
        - [PEStudio](https://www.winitor.com/download)
        - [Capa](https://github.com/mandiant/capa)
        - [Wireshark](https://www.wireshark.org/)
        - [Sysinternals (Procmon, TCPView)](https://learn.microsoft.comn-us/sysinternals/downloads/) | [Download sysinternals all](https://download.sysinternals.com/files/SysinternalsSuite.zip)
        - [nc/ncat](https://nmap.org/download)
        - [Cutter](https://github.com/rizinorg/cutter)
        - [x32/x64dbg](https://x64dbg.com/)
        - [Process Hacker 2 (now known as System Informer)](https:/ysteminformer.sourceforge.io/)
        - [scdbg](https://github.com/dzzie/SCDBG)
        - [dnSpy/dnSpyEx](https://github.com/dnSpyEx/dnSpy)
        - [PEBear](https://hshrzd.wordpress.com/pe-bear/)
        - [YARA](https://github.com/VirusTotal/yara)

    ??? info "REMnux"
    
        #### REMnux Tool List

        - base64 (built in Linux bin)
        - [OLEdump](https://github.com/DidierStevens/DidierStevensSuite/blob/master/oledump.py)
        - [MobSF github](https://github.com/MobSF/Mobile-Security-Framework-MobSF) | [(Docker Container)](https://hub.docker.com/r/opensecurity/mobile-security-framework-mobsf/)
        - [INetSim](https://www.inetsim.org/)


!!! info ""

    ### Get your Malware Samples here

    - [PMAT Labs](https://github.com/HuskyHacks/PMAT-labs)
    - [theZoo](https://github.com/ytisf/theZoo)
    - [vx-underground main site](https://www.vx-underground.org/)
    - [vx-underground GitHub repo](https://github.com/vxunderground/MalwareSourceCode)
    - [Zeltser Resources](https://zeltser.com/malware-sample-sources/)
    - [MalwareBazaar](https://bazaar.abuse.ch/###)



!!! info ""

    ### Basic Static Analysis

    **Basic**: Limited Triage approach to the tools and techniques we are using

    **Static**: Not running the binary

    ??? info "Binary Hashes"
        
        #### Pulling the Binary Hashes

        Pull the file hashes (Sha256 and MD5)

        ```bash
        sha256sum.exe <Malware_file_name.extension>
        md5sum.exe <Malware_file_name.extension>
        ```

        If using Cmder

        ```powershell
        Get-filehash -Algorithm SHA256 <Malware_file_name.extension>
        ```

        Submit the hashes to [VirusTotal](https://www.virustotal.com/gui/home/search) and see if you get something promising back!


    ??? info "Binary strings"

        #### strings

        Extract the Binary strings, you can use **strings** or **FLOSS**.
        Floss will pull any array of Char > len(4) and terminated with a NullByte

        ```bash
        floss <Malware_file_name.extension>

        #-n will look for a minimum string length of 8, you can change the value based on your needs.
        floss -n 8 <Malware_file_name.extension>
        ```

        Look through the output for any usable information, one of the most telling is the FLOSS static Unicode strings. Keep in mind that someone could put that there in purpose to mislead you while Analyzing the Malware sample.

    ??? info "Portable Executable Viewer - PEView"

        #### PEView
        
        run PEView > folder browser select "All File (*.*)" > locate your Malware sample > Click Open > It should load your Malware into the program

        **pFile** column: the offset of the Bytes, where in relation to the beginning of the Program did these Bits exist

        **Value** column: Char representation of the Bytes. Value MZ is a Windows EXE (Magic Byte tells what the file signature is)

        !!! example ""
            If you want to learn more about [Magic Bytes](https://www.netspi.com/blog/technical-blog/web-application-pentesting/magic-bytes-identifying-common-file-formats-at-a-glance/)

            [Interesting way of abusing the Magic Byte](https://medium.com/@d.harish008/what-is-a-magic-byte-and-how-to-exploit-1e286da1c198)

        **IMAGE_MT_HEADERS** > IMAGE_FILE_HEADER > Time Date Stamp
        - This is the time of build but sometimes this can be incorrect.
        - If the program was compiled with borland delphi compiler, the compile date will always be 1992
        
        **IMAGE_SECTION_HEADER.text**
        - **Virtual Size** (The amount of the data on disk when the Binary is run) & **Size of Raw Data **
        - Compare these HEX value using calc HEX
        - If the **Size of Raw Data ** < **Virtual Size** this could mean it's a packed Binary
          - In packed Binary the difference is very significant
          - ![alt text](/Knowledge_Base/images/PMA_Summary_1_2.png)

        **SECTION.rdata** > IMPORT_Address_Table
        
        !!! info ""
            This section is important because of the Windows API (Application Programming Interface)
            - APIs are readily accessible to C and C++ developers, other languages like C# and Rust require wrappers or bindings in order to access these APIs. Source [Windows Developer Blog - making win32 apis more accessible](https://blogs.windows.com/windowsdeveloper/2021/01/21/making-win32-apis-more-accessible-to-more-languages/)
            - What this means is that Malware creators can also make use of the Windows API.
            - [Windows win32 API](https://learn.microsoft.com/en-us/windows/win32/api/)
            
            ![alt text](/Knowledge_Base/images/PMA_Summary_1_3.png)

        Going back to the **IMPORT_Address_Table**
        
        !!! warning ""
            ##### unpacked Malware
            
            You can see all the Windows API Calls under the Value column for **IMPORT_Address_Table**

            ![alt text](/Knowledge_Base/images/PMA_Summary_1_0.png)        

        !!! warning ""
            ##### packed Malware

            You will see the packer name UPX in this case `SECTION UPX`
            You won't see all the Windows API calls under the Value column for **IMPORT_Address_Table**
            **LoadLibraryA** & **GetProcAddress** are used to identify other imports at runtime, on runtime it will go find the API calls from the dlls it loads in.

            ![alt text](/Knowledge_Base/images/PMA_Summary_1_5.png)

        For example if we see ShellExecuteW, we can google for "Windows API Shell ExecuteW", first link gets us to [nf-shellapi-shellexecutea](https://learn.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-shellexecutea) which will explain the API call function.

        Now if you want to get to the point and see exactly what could be malicious, you can check [**MalAPI.io**](https://malapi.io/)


    ??? info "Portable Executable Studio - PEStudio"

        #### PEStudio

        Before we get into it, always keep in mind the type of application and it's functionality when looking for file signatures. In below example you can see ShellExecuteA but the application is putty, which is a part of its functionality.

        ![alt text](/Knowledge_Base/images/PMA_Summary_s4_2.png)

        Run PEStudio > file > open file > select the malware sample > click Open

        PEStudio simplifies the early stages, when using Basic Static Analysis. For example it gives you the hashes right away, runs strings and presents many more pieces of information.

        ![alt text](/Knowledge_Base/images/PMA_Summary_1_4.png)


    ??? info "Detecting executable capabilities"

        #### [CAPA](https://github.com/mandiant/capa)

        CAPA detects malicious capabilities in suspicious programs by using a set of rules. Capa has a default rule set, but also has an open-source repository of rules [**CAPA rule repository**](https://github.com/mandiant/capa-rules)

        ![alt text](/Knowledge_Base/images/PMA_Summary_1_6.png)

        ![alt text](/Knowledge_Base/images/PMA_Summary_1_7.png)

        From the output we can then use the [**MITRE ATT&CK Framework**](https://attack.mitre.org/). In our example we have T1129, we can check that out through this link [MITRE T1129](https://attack.mitre.org/techniques/T1129/)


!!! info ""

    ### Basic Dynamic Analysis

    Also known as **Heuristic** or **Behavioral** Analysis. Dynamic Analysis means that we will execute/run the Malware and Analyze it.

    We will be looking for **Host Indicators** (Like deleting a local file) & **Network Indicators** (like calling out to the Internet to download a file).

    ??? info "Network Signatures"

        #### Hunting for Network Signatures

        Make sure all the tools are ready before executing the Malware (RemNux, Wireshark Capture on RemNux)

        We can start by looking for the Network Signatures now, based on the Static Analysis we did, we gathered possibly a domain name or a file name it's calling for. We can look for those into our Wireshark Capture.

        Once Network Signatures is complete, we can rollback out VM then run the Malware again to check for Local Signatures.


    ??? info "Local Signatures"

        #### Local Signatures - Procmon

        ??? info "Procmon overview"
        
            ##### overview

            Open Procmon > Click the Filter > setup the filter and click OK

            ![alt text](/Knowledge_Base/images/PMA_Summary_1_8.png)

            Since we know the process name we can setup something like this
            
            ![alt text](/Knowledge_Base/images/PMA_Summary_1_9.png)

            You won't see any events until you run the Malware sample

            ![alt text](/Knowledge_Base/images/PMA_Summary_1_10.png)

            You will now need to sift through the Operations 

            For example in the Static Analysis Stage we found a path with an exe name when we ran strings on the sample, after filtering through operations we found the same path

            ![alt text](/Knowledge_Base/images/PMA_Summary_1_11.png)

            Now we can go to that path and see what that executable is doing.

            **Keep going through all the interesting strings to gather more information**, try to extract the Malware flow such as if it deletes itself, call to download a file and so on.

            ![alt text](/Knowledge_Base/images/PMA_Summary_1_12.png)

        ??? info "Procmon common filters"

            ##### procmon filters

            **Common Operations filters**:

            - CreateFile: When a process wants to create a file.
            - WriteFile: When a process writes data to a file.
            - SetRenameInformationFile: When a rename operation occurs on a file.
            - SetDispositionInformationFile: When a file deletion occurs on a file.
            - RegCreateKey: When registry key is created.
            - RegSetValue: When the data for value is set in the registry
            - RegDeleteKey: When a key gets deleted from the registry.
            - RegDeleteValue: When a value gets deleted from the registry.
            - TCP Connect, TCP Receive, UDP Send, UDP Receive: Process is Sending / - Receiving a TCP or UDP connection.
            - Load Image: When a process loads any DLLâ€™s / Executables.
            - Process Create: When a process creates a process.
            - CreatePipe: When a process creates a Pipe.

            **Resources**:

            - [motiba](https://learn.microsoft.com/en-us/archive/blogs/motiba/process-monitor-for-dynamic-malware-analysis)
            - [system_monitor](https://github.com/wuanzhuan/system_monitor?tab=readme-ov-file)
            - [Lonebear69 filter import](https://github.com/Lonebear69/https-github.com-tanc7-procmon-filters)
            - [mindmap](https://www.mindmeister.com/app/map/55334446?fullscreen=1&v=public)


    ??? info "TCP View"

        #### TCP View

        Having TCP View running when we run the malware sample, we can then check the ports the malware is requesting.

        ![alt text](/Knowledge_Base/images/PMA_Summary_22.png)

        If we see one that's listening, we can go back to our RemNux machine and netcat `nc` that port to interact with the Malware and see what happens

        ![alt text](/Knowledge_Base/images/PMA_Summary_23.png)

        nc result

        ![alt text](/Knowledge_Base/images/PMA_Summary_24.png)

        decode the result with base64

        ![alt text](/Knowledge_Base/images/PMA_Summary_25.png)

        Now we know what it's asking for, a command. We ran the `ipconfig` and came back with a result

        ![alt text](/Knowledge_Base/images/PMA_Summary_26.png)

        decoded the result and it's showing us the network adapter configuration

        ![alt text](/Knowledge_Base/images/PMA_Summary_27.png)

        So the above tells us it had command injection capability

        We now can run procmon while interacting with the Malware sample

        ![alt text](/Knowledge_Base/images/PMA_Summary_28.png)

        We can see that it's sending the results back

        ![alt text](/Knowledge_Base/images/PMA_Summary_29.png)


    ??? info "Process Tree"

        #### Process Tree

        You will need to de-chain/decouple the Parent Child Process relationship.
        
        ![alt text](/Knowledge_Base/images/PMA_Summary_2_0_0.png)

        Knowing the PID for the parent process, we can now filter Procmon using Parent PID

        ![alt text](/Knowledge_Base/images/PMA_Summary_s4_0.png)

        ![alt text](/Knowledge_Base/images/PMA_Summary_s4_1.png)


    ??? info "Encoded files"

        #### Extracting encoded file

        Lets say you found a base64 string in a command running through powershell.exe

        ![alt text](/Knowledge_Base/images/PMA_Summary_s4_4.png)

        You can extract that string and decode it, then get the file type of whatever it decoded to

        ![alt text](/Knowledge_Base/images/PMA_Summary_s4_3.png)

        ```bash
        #decode to a file called out and has no file extension
        echo "XXX_VALUE_XXX" | base64 -d > out
        
        #figure out the file type
        file out
        
        #we can see in the example we have a gzip file
        #now you can extract the file and check its contents
        ```

!!! info ""

    ### Advanced Static Analysis: Assembly Language, Decompiling, & Disassembling Malware


    ??? info "Analysis & Assembly"

        #### Advanced Analysis & Assembly Language


    ??? info "Disassembling & Decompiling"

        #### Disassembling & Decompiling a Malware Dropper: Intro to Cutter


        Sample for this section: [Lab file(s)](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs//2-1.AdvancedStaticAnalysis/Dropper.DownloadFromURL.exe.malz/Dropper.DownloadFromURL.exe.7z)

	    [Lab file(s)](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs/2-1.AdvancedStaticAnalysis)

	    **Errata**
	    Please note that, depending on when you installed FLARE-VM, the installed tools may or may not include Cutter. If you don't see it when searching in the task bar, please download it from the official site here: https://cutter.re/



    ??? info "x86 CPU"

        #### x86 CPU Instructions, Memory Registers, & the Stack



    ??? info "Assembly Instructions & Windows API"

        #### Dropper: Assembly Instructions and the Windows API

        Sample for this section: [Lab file(s)](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs//2-1.AdvancedStaticAnalysis/Dropper.DownloadFromURL.exe.malz/Dropper.DownloadFromURL.exe.7z)

	    [Lab file(s)](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs/2-1.AdvancedStaticAnalysis)


    ??? info "Under a Microscope"

        #### Hello, World! Under a Microscope Part I

        Using cutter > load the malware sample in
        Now we need to see if the application was stripped of it's debug symbols or not, look for the dbg prefix for functions

        ![alt text](/Knowledge_Base/images/pma_img_s8js_0.png)

        You can also lookup the Disassembly
        ![alt text](/Knowledge_Base/images/pma_img_s8js_1.png)

        rdata is only used to hold readonly data inside a binary

        ![alt text](/Knowledge_Base/images/pma_img_s8js_2.png)

        Checking Hexdump

        ![alt text](/Knowledge_Base/images/pma_img_s8js_3.png)


    ??? info "Advanced Analysis of a Process Injector"

        #### Advanced Analysis of a Process Injector

        Malware that creates remote thread process Injection is common TTP (Tactics, Techniques, and Procedures)

        Process Injection: Open up another process that is running on the host and inject code right into that process and have that code run in that process as if that code was a part of that program in the first place.

        This isn't very stealthy now a days because defenders look for it.

        What does it look like?

        Opening up a process 
        ![alt text](/Knowledge_Base/images/pma_img_s8js_4.png)

        Next step, same logic, API call and passing parameters

        Allocating an area in memory with the writes to write into that memory

        ![alt text](/Knowledge_Base/images/pma_img_s8js_5.png)

        Taking the Bytes from the lpBuffer and writing them into that process in the section of memory that we've allocated

        ![alt text](/Knowledge_Base/images/pma_img_s8js_6.png)

        Create remote thread

        ![alt text](/Knowledge_Base/images/pma_img_s8js_7.png)

        Looking at the API call in the last screenshot to see what the ate the parameters that are being passed (1st & 4th)
        
        So that would be, 1st is hProcess & 4th is IpStartAddress
        hProcess has value of edi
        IpStartAddress has value of esi

        ![alt text](/Knowledge_Base/images/pma_img_s8js_8.png)

        and the value of esi that is being passed is
        ![alt text](/Knowledge_Base/images/pma_img_s8js_9.png)


        If we check the process in Process Hacker, we see the process used was WerFault.exe. Now if we go inspect the Memory we will see an unusual Protection of RW**X**
        
        ![alt text](/Knowledge_Base/images/pma_img_s9js_0.png)

        If we go into that RW**X** section of WerFault.exe, we will see the actual Bytes of the shell code written into this process

        ![alt text](/Knowledge_Base/images/pma_img_s9js_1.png)


!!! info ""

    ### Advanced Dynamic Analysis: Debugging Malware


    ??? info "Flow Control & Breakpoints"

        #### x32dbg: Flow Control & Breakpoints

        We will be using Debuggers (x32dbg & x64dbg)

        Load the Malware sample into x32dbg
        
        The CPU window shows the Assembly instructions that the program will execute
        Memory window shows the Memory Registers
        Stack windows shows any value that was pushed or popped from the stack
        
        ![alt text](/Knowledge_Base/images/PMA-apo-98hs-4.png)

        |Shortcut|Description|
        |:-|:-|
        |F2 |Breakpoint|
        |F9 |Run|
        |CTRL+F2 |Restart|
        |F7 |Step into|
        |F8 |Step over|
        |CTRL+G|Go to memory location|


    ??? info "Dynamic Analysis of x86"

        #### Debugging the Dropper: Dynamic Analysis of x86 Instructions & API Calls

        load the sample in x32dbg and run the program
        Keep hitting F8 until it hangs for a bit somewhere, that's where we start tracing

        On that hang point, set a breakpoint using F2

        We can also right-click > Follow in Disassembler > choose the location

        ![alt text](/Knowledge_Base/images/PMA-micro-s9a8s-0.png)

        If we followed it, it will show the following. You can see a call to the Windows API <mark>InternetOpenW</mark>

        We can also see the user agent being utilized for the Windows API call for InternetOpenW

        ![alt text](/Knowledge_Base/images/PMA-micro-s9a8s-2.png)

        We can do side by side Analysis, load up Cutter and open the same sample.

        Locate the same API aall and set them side by side to compare
        
        ![alt text](/Knowledge_Base/images/PMA-micro-s9a8s-1.png)

        Make sure inetsim is running and then open up Wireshark to run a capture.

        F7 step into the push one by one until we get to the actual API call and Wireshark is capturing any activity on the side.

        ![alt text](/Knowledge_Base/images/PMA-micro-s9a8s-3.png)

        ![alt text](/Knowledge_Base/images/PMA-micro-s9a8s-4.png)

        When the program jumps into the actual call it will process the actual call, keep going until it gets out.

        Keep doing this until the next call and so on...

        After the download API we see ```test eax,eax```, this is basically comparing eax to itself to see if the result is zero, we can see EAX is `00000000` therefor the ZF flag is set to 1.

        All of this is to confirm if the returned value of the download was good
        
        ![alt text](/Knowledge_Base/images/PMA-micro-s9a8s-5.png)

        Next is jne [jump if not zero], in this case the ZF is 1 so it won't go into that portion. If we want to see what the jne does, we can manually change the ZF value from `1` to `0`
        
        ![alt text](/Knowledge_Base/images/PMA-micro-s9a8s-6.png)

        We reached a ShellExecute, now we can open procmon at the same time and filter for DownloadFromURL and step in and see what's going on

        ![alt text](/Knowledge_Base/images/PMA-micro-s9a8s-7.png)

        F8 until we get the Download File call, locate the file on the file system

        ![alt text](/Knowledge_Base/images/PMA-micro-s9a8s-8.png)



    ??? info "Under a Microscope"

        #### Hello, World! Under a Microscope Part II

        Another way of starting the debugging is by loading the sample into cutter and getting the memory address of the main function so then we can use that to start with in x32dbg

        Cutter main function memory location

        ![alt text](/Knowledge_Base/images/PMA-micro-s9a8s-9.png)

        x32dbg start with memory location

        In x32dbg CTRL+G and paste the memory location then click OK

        ![alt text](/Knowledge_Base/images/PMA-micro-s9a8s-10.png)

        Now we are at the main function, we then set a breakpoint to the memory location and the printf

        ![alt text](/Knowledge_Base/images/PMA-micro-s9a8s-11.png)

        Start with F9 and hit it until you get to the breakpoint.

        So because it's located in memory we can watch our registers as the instructions take place. If you follow in Disassembler you will be brought to the instruction point where we return after this functions returns

        ![alt text](/Knowledge_Base/images/PMA-micro-s9a8s-13.png)

        x32dbg anywhere there is an instruction that will act on one of the registers the debugger will highlight that for us

        ![alt text](/Knowledge_Base/images/PMA-micro-s9a8s-12.png)

        ![alt text](/Knowledge_Base/images/PMA-micro-s9a8s-14.png)

        Move the value to esp, but before it moved we can actually edit the value being sent over
        
        ![alt text](/Knowledge_Base/images/PMA-micro-s9a8s-16.png)

        To edit what's being printed out, we need to know how many bytes we are changing. In this case "Hello, World!" is 13 Bytes
        
        ![alt text](/Knowledge_Base/images/PMA-micro-s9a8s-15.png)



!!! info ""

    ### SikoMode

    [SikoMode Lab](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs/2-3.Challenge-SikoMode)




!!! info ""

    ### Binary Patching & Anti-analysis


    ??? info "Setting Up"

        #### Setting Up

        Make a copy of the binary and open it in cutter "Load in write mode"

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-1.png)

        open the main() function in the Decompiler panel

        Now we need to find a way of tricking the Malware, so in case of a function that calls to exit if cannot reach a website or check something. We can change the jne (jump if not equal) instruction to je (jump if equal), then we save it as a new binary to run.

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-2.png)



    ??? info "Identifying & Defeating Anti-analysis Techniques"

        #### Identifying & Defeating Anti-analysis Techniques

        [simpleAntiAnalysis Lab](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs/2-5.AntiAnalysis/1.simpleAntiAnalysis)

        All of these techniques belong to the Defense Evasion tactic:

        - [Virtualization/Sandbox Evasion](https://attack.mitre.org/techniques/T1497/)
        - [Debugger Evasion](https://attack.mitre.org/techniques/T1622/)
        - [Execution Guardrails](https://attack.mitre.org/techniques/T1480/)



!!! info ""

    ### Gone Phishing: Maldoc Analysis

    ??? info "Analyzing Excel Maldocs: OLEdump"

        #### Analyzing Excel Maldocs: OLEdump

        [Gone Phishing Excel Lab](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs/3-1.GonePhishing-MaldocAnalysis/Excel)

        We can just use Remnux for this one

        ```bash
        #unzip the excel sheet
        unzip xxxx.xlsm
        ```

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-24.png)

        ```bash
        cd xl
        cat vbaProject.bin
        #now we will get teh raw bits for this bin

        #we can use oledump.py for this
        oledump.py xxxx.xlsm
        ```

        The As are indexes of data streams that were identified by oledump
        The M is Macro inside that data stream
        
        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-25.png)

        Now we can choose one of those Indexes that we want to dig in

        ```bash
        oledump.py -s 3 xxx.xlsm
        ```

        This will show us the HEXDump

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-26.png)

        ```bash
        #Instead to make it easier, we will do capital S for Strings
        oledump.py -s 3 -S xxx.xlsm
        ```

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-27.png)

        ```bash
        #Attempt to recover the Macro
        oledump.py -s 3 --vbadecompresscorrupt xxx.xlsm
        ```

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-28.png)


    ??? info "Analyzing Word Maldocs: Remote Template Macro Injection"

        #### Analyzing Word Maldocs: Remote Template Macro Injection

        [Gone Phishing Word Lab](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs/3-1.GonePhishing-MaldocAnalysis/Word)

        docm > Macro enabled document
        docx > Can contain Macros

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-29.png)

        ```bash
        oledump.py xxx.docm
        ```

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-30.png)

        This sample has the same vba in the excel example, so from here on now is the same as the previous example.

        The rels is something you will find in polished documents

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-31.png)

        What this file looks like

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-32.png)

        The document when it loads, it will go to the link to download the polished document. You can put a link to a Macro and once it pull sit, it will execute it.

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-33.png)

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-34.png)


!!! info ""

    ### What The Shell? Shellcode Analysis

    ??? info "Analyzing Shellcode: Carving Shellcode & scdbg"

        #### Analyzing Shellcode: Carving Shellcode & scdbg

        [Carve from text Lab](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs/3-2.WhatTheShell-ShellcodeAnalysis/CarveFromText)

        Note: scdbg is available [Here](https://github.com/dzzie/VS_LIBEMU/releases/download/12.7.22/VS_LIBEMU_12_7_22.zip) if it is not installed in FLARE-VM 

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-35.png)

        0xfc
        in C# 0x denotes a Hex Bytes, the following 2 alpha numeric characters represented for the Hex Bytes (the actual data of the Hex Byte)

        We will extract that value from the original C# code and put it into a txt file.
        
        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-36.png)

        We will create a Python carver to clean up the txt file Hex, name it `carver.py`

        ```python
        #python carver
        #!/user/bin/env python3
        with open("xx.txt","r") as f:
                hex_string = f.read().replace("0x","").replace("byte[] rsrc = new byte[464] {","").replace(" };","").replace(",","")
                hex_encode = hex_string.encode()
        print(hex_string)
        print(hex_encode)
        ```

        we can test this out `python3 carver.py` check the results, if looks good we will get back to make some updates to our script


        ```python
        #python carver
        #!/user/bin/env python3
        with open("xx.txt","r") as f:
                hex_string = f.read().replace("0x","").replace("byte[] rsrc = new byte[464] {","").replace(" };","").replace(",","")
                hex_encode = hex_string.encode()
        
        with open ("out.bin","wb") as out
            out.write(hex_encode)
        ```

        `python3 carver.py`

        `cat out.bin`

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-37.png)

        We will now move this out.bin to FLare-vm

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-38.png)

        ```powershell
        #we will use shell code debug
        scdbg /f out.bin -s -1
        ```
        
        `scdbg` will resolve all steps without running the malware sample

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-39.png)

        We can see what it's calling

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-40.png)


    ??? info "Carving Shellcode from Memory"

        #### Carving Shellcode from Memory

        [Carving from Memory Lab](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs/3-2.WhatTheShell-ShellcodeAnalysis/CarveFromMemory)

        Addendum: Find the exact size of the shellcode
        If I'm feeling lazy, I will usually copy contiguous bytes from memory until I hit a bunch of null bytes (\x00), which is usually good enough. However, there are more scientific ways to get the exact size of the shellcode so we know exactly how much we need to copy out of memory.

        In this example, the size of the buffer that the program is injecting is known and used elsewhere during the injection routine. For example, the VirtualAllocEx call is executed before the WriteProcessMemoryEx call. VirtualAllocEx sets up the section of memory and changes the RWX permissions so the shellcode is executable.

        According to the documentation, VirtualAllocEx takes in four parameters. The third parameter is the dwSize parameter, which is the size of the buffer in bytes:

        > [in] dwSize: `The size of the region of memory to allocate, in bytes.`

        If we locate the VirtualAllocEx call, which is right before WriteProcessMemory, and set a breakpoint on the third parameter that is moved into the registers before it is called, we see that it moves a value from RDX into R8 to set up for that call. If we look at RDX when the move takes place, it's the hex value `0x01D1`, which corresponds to the decimal value 465, so we know the shellcode is 465 bytes. Then, do some memory address hex math and you know where to start and where to end.

        If we load the sample into `pestudio` we will see the Win API Calls, we want to debug just before it writes to memory.

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-41.png)

        Load the sample int `Cutter`, we can see that we do not have any Debug symbols, so this is going to make it a bit harder to analyze.

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-42.png)

        What we can do, is start from the end of the program, find the last place a function returned something into the `EAX`

        enterypoint => CRT (preamble to run this program) => main
        - so what this means, when the program runs, the entrypoint is the first thing calls, however, it isn't the main function.
        - The entrypoint sets up the CRT - C Run Time, in CRT the last thing that happens is a call to the main function.
        - If we do this in reverse, the last thing that was called, is going to return from main function into the CRT.
        - SO basically, we need to look al the last thing that was called into CRT.

        So now we will load the `graph` view and go all the way to the bottom and start from there

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-43.png)

        Check the `EAX` dword value that was called, click on the value so it would highlight all the places this value was used

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-44.png)

        Looks like last time it was called it was in this section (3rd from bottom). Just before that we see a `call` function, that function returns the value that will be used in `EAX`.  There is a chance that this is the actual `main` function. Double click on that call

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-45.png)

        Now we are in that function
        
        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-46.png)

        Lets rename the function, right click > `Re-type Local Variable`

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-47.png)

        Name it main and click ok

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-48.png)

        We will start with the last call in `main`, double click it to load the function

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-49.png)

        If we then scroll down and look at the call, we will see the Win API Calls

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-51.png)

        Now since we know which calls are being made through `cutter`, we can just take the memory location for the function. The one we want to dig in, will be the `WriteProcessMemory`

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-52.png)

        Now open the sample in `x64dbg', navigate to the CPU section and `CTRL + G` then paste the memory value


        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-53.png)

        Click F2 to set a breakpoint on the `WriteProcessMemory` Win API Call

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-54.png)

        If we check what the API documentation, we can see what it takes and what it outputs

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-56.png)

        The one we are intrested in is the `lpBuffer`, this is where the Malware is trying to inject itself into

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-55.png)

        Set the breakpoint on the call itself now

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-57.png)

        If we actually look back to see the parameters passed to the API, we can see the lpBuffer value is the `r8,rcx`

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-58.png)

        Right click the lpBuffer value `r8,rcx` > Follow in Dump > select the r8

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-59.png)

        We can see the shell Bytes

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-60.png)

        Highlight all the shell Bytes > right click > Binary > Save To a File
        
        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-61.png)


        Save it to dump.bin

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-62.png)

        We can now open a Hex Editor like `HxD` then load the Binary into it

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-63.png)

        The better tool to use would be shell code debug `scdbg`, open a shell session and type the following

        ```powershell
        scdbg /f .\dump.bin /s -1 
        ```

        Now we can see all the Win API Calls

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-64.png)


!!! info ""

    ### Off-Script: Scripted Malware Delivery Mechanisms


    ??? info "PowerShell: Analyzing Obfuscated Scripts"

        #### PowerShell: Analyzing Obfuscated Scripts

        [PowerShell Lab](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs/3-3.OffScript-ScriptMalware/PowerShell)


        **Powershell** is an interpreter for the .Net Framework

        Arm the sample and loaded it in vsCode > `ALT + Z` to word wrap

        So this sample is converting Base64 into a String, it then will decompress the String. The output will then be passed into the 2nd phase of Encoding to ACII
        
        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-65.png)

        So lets defang the sample by taking out the Invoke Expression `iEx(` and the last bracket `)`, now we can assign the remianing to a variable

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-68.png)

        Open a shell session and declare your variable `$megasus = ` then paste the value you copied previously, the defanged script

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-69.png)

        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-70.png)

        So instead of Invoking the expression and have it do its thing, we will do the following

        ```powershell
        write-host $megasus
        #hit enter
        ```

        Now we can see the Malware script wihtout detonating it, so it decoded and deinflated the sample by doing that.
        
        ![alt text](/Knowledge_Base/images/PMA-IMG-SMa7iyhn-71.png)


    ??? info "VBScript: Analyzing a Multi-Stage MSBuild Dropper"

        #### VBScript: Analyzing a Multi-Stage MSBuild Dropper

        [VBScript Lab](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs/3-3.OffScript-ScriptMalware/VBScript)












    ??? info "HTML Applications (HTA): Wrapped Payloads, Scripted Delivery, & WMI"

        #### HTML Applications (HTA): Wrapped Payloads, Scripted Delivery, & WMI

        [HTA Lab](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs/3-3.OffScript-ScriptMalware/HTA)







!!! info ""

    ### Stay Sharp: Reversing C# Malware

    ??? info "Intro to Reversing C# & the .NET Framework"

        #### Intro to Reversing C# & the .NET Framework













    ??? info "Reversing an Encrypted C2 Dropper DLL with dnSpy"

        #### Reversing an Encrypted C2 Dropper DLL with dnSpy







!!! info ""

    ### Go Time: Analyzing Go Malware

    ??? info "Programming Language Recognition & Analyzing a Go Service Backdoor"

        #### Programming Language Recognition & Analyzing a Go Service Backdoor





!!! info ""

    ### Get Mobile! Mobile Malware Analysis

    ??? info "Lab Update: Installing MobSF"

        #### Lab Update: Installing MobSF













    ??? info "Intro to MobSF"

        ####   Intro to MobSF










!!! info ""

    ### The Bossfight! Analyzing Real-World Malware Samples

    ??? info "WannaCry.exe Introduction"

        #### WannaCry.exe Introduction













    ??? info "WannaCry.exe Walkthrough"

        #### WannaCry.exe Walkthrough










!!! info ""

    ### Automation: Sandboxes & Pipelines

    ??? info "BlueJupyter: Automating Triage with Jupyter Notebooks"

        #### BlueJupyter: Automating Triage with Jupyter Notebooks













    ??? info "Any.Run: Malware Sandboxing"

        #### Any.Run: Malware Sandboxing













    ??? info "Advanced Script Analysis with ChatGPT"

        #### Advanced Script Analysis with ChatGPT










!!! info ""

    ### Tell The World: Rule Writing & Report Publishing
    
    ??? info "Writing YARA Rules"

        #### Writing YARA Rules













    ??? info "Detecting Malware with YARA"

        #### Detecting Malware with YARA













    ??? info "Writing & Publishing a Malware Analysis Report"

        #### Writing & Publishing a Malware Analysis Report








??? info "mindmaps"

    #### mindmaps

    ![alt text](/Knowledge_Base/images/PMA_Summary_20.png)

    ![alt text](/Knowledge_Base/images/PMA_Summary_21.png)




---


??? info "Additional resources"

    #### Additional resources

    - SANS Malware Analysis and Reverse-Engineering Cheat Sheet [click to open PDF in new tab](/Knowledge_Base/images/SANS_Malware_Analysis_&_Reverse_Engineering_Cheat_Sheet.pdf)
    [fareedfauzi](- https://fareedfauzi.github.io/2022/08/08/Malware-analysis-cheatsheet.html#ransomware-flow-101)

