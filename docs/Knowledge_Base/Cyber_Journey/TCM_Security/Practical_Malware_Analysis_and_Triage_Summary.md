!!! info ""

    ### Tools list

    ??? info "FLARE-VM"
        #### FLARE-VM Tool List

        - [strings/FLOSS](https://github.com/mandiant/flare-floss)
        - [PEView](http://wjradburn.com/software/)
        - [upx (not used but referenced)](https://upx.github.io/)
        - [PEStudio](https://www.winitor.com/download)
        - [Capa](https://github.com/mandiant/capa)
        - [Wireshark](https://www.wireshark.org/)
        - [Sysinternals (Procmon, TCPView)](https://learn.microsoft.comn-us/sysinternals/downloads/) | [Download sysinternals all](https://download.sysinternals.com/files/SysinternalsSuite.zip)
        - [nc/ncat](https://nmap.org/download)
        - [Cutter](https://github.com/rizinorg/cutter)
        - [x32/x64dbg](https://x64dbg.com/)
        - [Process Hacker 2 (now known as System Informer)](https:/ysteminformer.sourceforge.io/)
        - [scdbg](https://github.com/dzzie/SCDBG)
        - [dnSpy/dnSpyEx](https://github.com/dnSpyEx/dnSpy)
        - [PEBear](https://hshrzd.wordpress.com/pe-bear/)
        - [YARA](https://github.com/VirusTotal/yara)

    ??? info "REMnux"
    
        #### REMnux Tool List

        - base64 (built in Linux bin)
        - [OLEdump](https://github.com/DidierStevens/DidierStevensSuite/blob/master/oledump.py)
        - [MobSF github](https://github.com/MobSF/Mobile-Security-Framework-MobSF) | [(Docker Container)](https://hub.docker.com/r/opensecurity/mobile-security-framework-mobsf/)
        - [INetSim](https://www.inetsim.org/)


!!! info ""

    ### Get your Malware here
    - [PMAT Labs](https://github.com/HuskyHacks/PMAT-labs)
    - [theZoo](https://github.com/ytisf/theZoo)
    - [vx-underground main site](https://www.vx-underground.org/)
    - [vx-underground GitHub repo](https://github.com/vxunderground/MalwareSourceCode)
    - [Zeltser Resources](https://zeltser.com/malware-sample-sources/)
    - [MalwareBazaar](https://bazaar.abuse.ch/###)



!!! info ""

    ### Basic Static Analysis

    **Basic**: Limited Triage approach to the tools and techniques we are using

    **Static**: Not running the binary

    ??? info "Binary Hashes"
        
        #### Pulling the Binary Hashes

        Pull the file hashes (Sha256 and MD5)

        ```bash
        sha256sum.exe <Malware_file_name.extension>
        md5sum.exe <Malware_file_name.extension>
        ```

        If using Cmder

        ```powershell
        Get-filehash -Algorithm SHA256 <Malware_file_name.extension>
        ```

        Submit the hashes to [VirusTotal](https://www.virustotal.com/gui/home/search) and see if you get something promising back!


    ??? info "Binary strings"

        #### strings

        Extract the Binary strings, you can use **strings** or **FLOSS**.
        Floss will pull any array of Char > len(4) and terminated with a NullByte

        ```bash
        floss <Malware_file_name.extension>

        #-n will look for a minimum string length of 8, you can change the value based on your needs.
        floss -n 8 <Malware_file_name.extension>
        ```

        Look through the output for any usable information, one of the most telling is the FLOSS static Unicode strings. Keep in mind that someone could put that there in purpose to mislead you while Analyzing the Malware sample.

    ??? info "Portable Executable Viewer - PEView"

        #### PEView
        
        run PEView > folder browser select "All File (*.*)" > locate your Malware sample > Click Open > It should load your Malware into the program

        **pFile** column: the offset of the Bytes, where in relation to the beginning of the Program did these Bits exist

        **Value** column: Char representation of the Bytes. Value MZ is a Windows EXE (Magic Byte tells what the file signature is)

        !!! example ""
            If you want to learn more about [Magic Bytes](https://www.netspi.com/blog/technical-blog/web-application-pentesting/magic-bytes-identifying-common-file-formats-at-a-glance/)

            [Interesting way of abusing the Magic Byte](https://medium.com/@d.harish008/what-is-a-magic-byte-and-how-to-exploit-1e286da1c198)

        **IMAGE_MT_HEADERS** > IMAGE_FILE_HEADER > Time Date Stamp
        - This is the time of build but sometimes this can be incorrect.
        - If the program was compiled with borland delphi compiler, the compile date will always be 1992
        
        **IMAGE_SECTION_HEADER.text**
        - **Virtual Size** (The amount of the data on disk when the Binary is run) & **Size of Raw Data **
        - Compare these HEX value using calc HEX
        - If the **Size of Raw Data ** < **Virtual Size** this could mean it's a packed Binary
          - In packed Binary the difference is very significant
          - ![alt text](/Knowledge_Base/images/PMA_Summary_1_2.png)

        **SECTION.rdata** > IMPORT_Address_Table
        
        !!! info ""
            This section is important because of the Windows API (Application Programming Interface)
            - APIs are readily accessible to C and C++ developers, other languages like C# and Rust require wrappers or bindings in order to access these APIs. Source [Windows Developer Blog - making win32 apis more accessible](https://blogs.windows.com/windowsdeveloper/2021/01/21/making-win32-apis-more-accessible-to-more-languages/)
            - What this means is that Malware creators can also make use of the Windows API.
            - [Windows win32 API](https://learn.microsoft.com/en-us/windows/win32/api/)
            
            ![alt text](/Knowledge_Base/images/PMA_Summary_1_3.png)

        Going back to the **IMPORT_Address_Table**
        
        !!! warning ""
            ##### unpacked Malware
            
            You can see all the Windows API Calls under the Value column for **IMPORT_Address_Table**

            ![alt text](/Knowledge_Base/images/PMA_Summary_1_0.png)        

        !!! warning ""
            ##### packed Malware

            You will see the packer name UPX in this case `SECTION UPX`
            You won't see all the Windows API calls under the Value column for **IMPORT_Address_Table**
            **LoadLibraryA** & **GetProcAddress** are used to identify other imports at runtime, on runtime it will go find the API calls from the dlls it loads in.

            ![alt text](/Knowledge_Base/images/PMA_Summary_1_5.png)

        For example if we see ShellExecuteW, we can google for "Windows API Shell ExecuteW", first link gets us to [nf-shellapi-shellexecutea](https://learn.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-shellexecutea) which will explain the API call function.

        Now if you want to get to the point and see exactly what could be malicious, you can check [**MalAPI.io**](https://malapi.io/)


    ??? info "Portable Executable Studio - PEStudio"

        #### PEStudio

        Before we get into it, always keep in mind the type of application and it's functionality when looking for file signatures. In below example you can see ShellExecuteA but the application is putty, which is a part of its functionality.

        ![alt text](/Knowledge_Base/images/PMA_Summary_s4_2.png)

        Run PEStudio > file > open file > select the malware sample > click Open

        PEStudio simplifies the early stages, when using Basic Static Analysis. For example it gives you the hashes right away, runs strings and presents many more pieces of information.

        ![alt text](/Knowledge_Base/images/PMA_Summary_1_4.png)


    ??? info "Detecting executable capabilities"

        #### [CAPA](https://github.com/mandiant/capa)

        CAPA detects malicious capabilities in suspicious programs by using a set of rules. Capa has a default rule set, but also has an open-source repository of rules [**CAPA rule repository**](https://github.com/mandiant/capa-rules)

        ![alt text](/Knowledge_Base/images/PMA_Summary_1_6.png)

        ![alt text](/Knowledge_Base/images/PMA_Summary_1_7.png)

        From the output we can then use the [**MITRE ATT&CK Framework**](https://attack.mitre.org/). In our example we have T1129, we can check that out through this link [MITRE T1129](https://attack.mitre.org/techniques/T1129/)


!!! info ""

    ### Basic Dynamic Analysis

    Also known as **Heuristic** or **Behavioral** Analysis. Dynamic Analysis means that we will execute/run the Malware and Analyze it.

    We will be looking for **Host Indicators** (Like deleting a local file) & **Network Indicators** (like calling out to the Internet to download a file).

    ??? info "Network Signatures"

        #### Hunting for Network Signatures

        Make sure all the tools are ready before executing the Malware (RemNux, Wireshark Capture on RemNux)

        We can start by looking for the Network Signatures now, based on the Static Analysis we did, we gathered possibly a domain name or a file name it's calling for. We can look for those into our Wireshark Capture.

        Once Network Signatures is complete, we can rollback out VM then run the Malware again to check for Local Signatures.


    ??? info "Local Signatures"

        #### Local Signatures - Procmon

        ??? info "Procmon overview"
        
            ##### overview

            Open Procmon > Click the Filter > setup the filter and click OK

            ![alt text](/Knowledge_Base/images/PMA_Summary_1_8.png)

            Since we know the process name we can setup something like this
            
            ![alt text](/Knowledge_Base/images/PMA_Summary_1_9.png)

            You won't see any events until you run the Malware sample

            ![alt text](/Knowledge_Base/images/PMA_Summary_1_10.png)

            You will now need to sift through the Operations 

            For example in the Static Analysis Stage we found a path with an exe name when we ran strings on the sample, after filtering through operations we found the same path

            ![alt text](/Knowledge_Base/images/PMA_Summary_1_11.png)

            Now we can go to that path and see what that executable is doing.

            **Keep going through all the interesting strings to gather more information**, try to extract the Malware flow such as if it deletes itself, call to download a file and so on.

            ![alt text](/Knowledge_Base/images/PMA_Summary_1_12.png)

        ??? info "Procmon common filters"

            ##### procmon filters

            **Common Operations filters**:

            - CreateFile: When a process wants to create a file.
            - WriteFile: When a process writes data to a file.
            - SetRenameInformationFile: When a rename operation occurs on a file.
            - SetDispositionInformationFile: When a file deletion occurs on a file.
            - RegCreateKey: When registry key is created.
            - RegSetValue: When the data for value is set in the registry
            - RegDeleteKey: When a key gets deleted from the registry.
            - RegDeleteValue: When a value gets deleted from the registry.
            - TCP Connect, TCP Receive, UDP Send, UDP Receive: Process is Sending / - Receiving a TCP or UDP connection.
            - Load Image: When a process loads any DLL’s / Executables.
            - Process Create: When a process creates a process.
            - CreatePipe: When a process creates a Pipe.

            **Resources**:

            - [motiba](https://learn.microsoft.com/en-us/archive/blogs/motiba/process-monitor-for-dynamic-malware-analysis)
            - [system_monitor](https://github.com/wuanzhuan/system_monitor?tab=readme-ov-file)
            - [Lonebear69 filter import](https://github.com/Lonebear69/https-github.com-tanc7-procmon-filters)
            - [mindmap](https://www.mindmeister.com/app/map/55334446?fullscreen=1&v=public)


    ??? info "TCP View"

        #### TCP View

        Having TCP View running when we run the malware sample, we can then check the ports the malware is requesting.

        ![alt text](/Knowledge_Base/images/PMA_Summary_22.png)

        If we see one that's listening, we can go back to our RemNux machine and netcat `nc` that port to interact with the Malware and see what happens

        ![alt text](/Knowledge_Base/images/PMA_Summary_23.png)

        nc result

        ![alt text](/Knowledge_Base/images/PMA_Summary_24.png)

        decode the result with base64

        ![alt text](/Knowledge_Base/images/PMA_Summary_25.png)

        Now we know what it's asking for, a command. We ran the `ipconfig` and came back with a result

        ![alt text](/Knowledge_Base/images/PMA_Summary_26.png)

        decoded the result and it's showing us the network adapter configuration

        ![alt text](/Knowledge_Base/images/PMA_Summary_27.png)

        So the above tells us it had command injection capability

        We now can run procmon while interacting with the Malware sample

        ![alt text](/Knowledge_Base/images/PMA_Summary_28.png)

        We can see that it's sending the results back

        ![alt text](/Knowledge_Base/images/PMA_Summary_29.png)


    ??? info "Process Tree"

        #### Process Tree

        You will need to de-chain/decouple the Parent Child Process relationship.
        
        ![alt text](/Knowledge_Base/images/PMA_Summary_2_0_0.png)

        Knowing the PID for the parent process, we can now filter Procmon using Parent PID

        ![alt text](/Knowledge_Base/images/PMA_Summary_s4_0.png)

        ![alt text](/Knowledge_Base/images/PMA_Summary_s4_1.png)


    !!! info "Encoded files"

        #### Extracting encoded file

        Lets say you found a base64 string in a command running through powershell.exe

        ![alt text](/Knowledge_Base/images/PMA_Summary_s4_4.png)

        You can extract that string and decode it, then get the file type of whatever it decoded to

        ![alt text](/Knowledge_Base/images/PMA_Summary_s4_3.png)

        ```bash
        #decode to a file called out and has no file extension
        echo "XXX_VALUE_XXX" | base64 -d > out
        
        #figure out the file type
        file out
        
        #we can see in the example we have a gzip file
        #now you can extract the file and check its contents
        ```

!!! info ""

    ### Advanced Static Analysis: Assembly Language, Decompiling, & Disassembling Malware


    ??? info "Analysis & Assembly"

        #### Advanced Analysis & Assembly Language





    ??? info "Disassembling & Decompiling"

        #### Disassembling & Decompiling a Malware Dropper: Intro to Cutter





    ??? info "x86 CPU"

        #### x86 CPU Instructions, Memory Registers, & the Stack






    ??? info "Assembly Instructions & Windows API"

        #### Dropper: Assembly Instructions and the Windows API


    ??? info "Under a Microscope"

        #### Hello, World! Under a Microscope Part I

        Using cutter > load the malware sample in
        Now we need to see if the application was stripped of it's debug symbols or not, look for the dbg prefix for functions

        ![alt text](/Knowledge_Base/images/pma_img_s8js_0.png)

        You can also lookup the Disassembly
        ![alt text](/Knowledge_Base/images/pma_img_s8js_1.png)

        rdata is only used to hold readonly data inside a binary

        ![alt text](/Knowledge_Base/images/pma_img_s8js_2.png)

        Checking Hexdump

        ![alt text](/Knowledge_Base/images/pma_img_s8js_3.png)


    ??? info "Advanced Analysis of a Process Injector"

        #### Advanced Analysis of a Process Injector

        Malware that creates remote thread process Injection is common TTP (Tactics, Techniques, and Procedures)

        Process Injection: Open up another process that is running on the host and inject code right into that process and have that code run in that process as if that code was a part of that program in the first place.

        This isn't very stealthy now a days because defenders look for it.

        What does it look like?

        Opening up a process 
        ![alt text](/Knowledge_Base/images/pma_img_s8js_4.png)

        Next step, same logic, API call and passing parameters

        Allocating an area in memory with the writes to write into that memory

        ![alt text](/Knowledge_Base/images/pma_img_s8js_5.png)

        Taking the Bytes from the lpBuffer and writing them into that process in the section of memory that we've allocated

        ![alt text](/Knowledge_Base/images/pma_img_s8js_6.png)

        Create remote thread

        ![alt text](/Knowledge_Base/images/pma_img_s8js_7.png)

        Looking at the API call in the last screenshot to see what the ate the parameters that are being passed (1st & 4th)
        
        So that would be, 1st is hProcess & 4th is IpStartAddress
        hProcess has value of edi
        IpStartAddress has value of esi

        ![alt text](/Knowledge_Base/images/pma_img_s8js_8.png)

        and the value of esi that is being passed is
        ![alt text](/Knowledge_Base/images/pma_img_s8js_9.png)


        If we check the process in Process Hacker, we see the process used was WerFault.exe. Now if we go inspect the Memory we will see an unusual Protection of RW**X**
        
        ![alt text](/Knowledge_Base/images/pma_img_s9js_0.png)

        If we go into that RW**X** section of WerFault.exe, we will see the actual Bytes of the shell code written into this process

        ![alt text](/Knowledge_Base/images/pma_img_s9js_1.png)


!!! info ""

    ### Advanced Dynamic Analysis: Debugging Malware


    ??? info "Flow Control & Breakpoints"

        #### x32dbg: Flow Control & Breakpoints

        We will be using Debuggers (x32dbg & x64dbg)

        Load the Malware sample into x32dbg
        
        The CPU window shows the Assembly instructions that the program will execute
        Memory window shows the Memory Registers
        Stack windows shows any value that was pushed or popped from the stack
        
        ![alt text](/Knowledge_Base/images/PMA-apo-98hs-4.png)

        |Shortcut|Description|
        |:-|:-|
        |F2 |Breakpoint|
        |F9 |Run|
        |CTRL+F2 |Restart|
        |F7 |Step into|
        |F8 |Step over|
        |CTRL+G|Go to memory location|


    ??? info "Dynamic Analysis of x86"

        #### Debugging the Dropper: Dynamic Analysis of x86 Instructions & API Calls

        load the sample in x32dbg and run the program
        Keep hitting F8 until it hangs for a bit somewhere, that's where we start tracing

        On that hang point, set a breakpoint using F2

        We can also right-click > Follow in Disassembler > choose the location

        ![alt text](/Knowledge_Base/images/PMA-micro-s9a8s-0.png)

        If we followed it, it will show the following. You can see a call to the Windows API <mark>InternetOpenW</mark>

        We can also see the user agent being utilized for the Windows API call for InternetOpenW

        ![alt text](/Knowledge_Base/images/PMA-micro-s9a8s-2.png)

        We can do side by side Analysis, load up Cutter and open the same sample.

        Locate the same API aall and set them side by side to compare
        
        ![alt text](/Knowledge_Base/images/PMA-micro-s9a8s-1.png)

        Make sure inetsim is running and then open up Wireshark to run a capture.

        F7 step into the push one by one until we get to the actual API call and Wireshark is capturing any activity on the side.

        ![alt text](/Knowledge_Base/images/PMA-micro-s9a8s-3.png)

        ![alt text](/Knowledge_Base/images/PMA-micro-s9a8s-4.png)

        When the program jumps into the actual call it will process the actual call, keep going until it gets out.

        Keep doing this until the next call and so on...

        After the download API we see ```test eax,eax```, this is basically comparing eax to itself to see if the result is zero, we can see EAX is `00000000` therefor the ZF flag is set to 1.

        All of this is to confirm if the returned value of the download was good
        
        ![alt text](/Knowledge_Base/images/PMA-micro-s9a8s-5.png)

        Next is jne [jump if not zero], in this case the ZF is 1 so it won't go into that portion. If we want to see what the jne does, we can manually change the ZF value from `1` to `0`
        
        ![alt text](/Knowledge_Base/images/PMA-micro-s9a8s-6.png)

        We reached a ShellExecute, now we can open procmon at the same time and filter for DownloadFromURL and step in and see what's going on

        ![alt text](/Knowledge_Base/images/PMA-micro-s9a8s-7.png)

        F8 until we get the Download File call, locate the file on the file system

        ![alt text](/Knowledge_Base/images/PMA-micro-s9a8s-8.png)



    ??? info "Under a Microscope"

        #### Hello, World! Under a Microscope Part II

        Another way of starting the debugging is by loading the sample into cutter and getting the memory address of the main function so then we can use that to start with in x32dbg

        Cutter main function memory location

        ![alt text](/Knowledge_Base/images/PMA-micro-s9a8s-9.png)

        x32dbg start with memory location

        In x32dbg CTRL+G and paste the memory location then click OK

        ![alt text](/Knowledge_Base/images/PMA-micro-s9a8s-10.png)

        Now we are at the main function, we then set a breakpoint to the memory location and the printf

        ![alt text](/Knowledge_Base/images/PMA-micro-s9a8s-11.png)

        Start with F9 and hit it until you get to the breakpoint.

        So because it's located in memory we can watch our registers as the instructions take place. If you follow in Disassembler you will be brought to the instruction point where we return after this functions returns

        ![alt text](/Knowledge_Base/images/PMA-micro-s9a8s-13.png)

        x32dbg anywhere there is an instruction that will act on one of the registers the debugger will highlight that for us

        ![alt text](/Knowledge_Base/images/PMA-micro-s9a8s-12.png)

        ![alt text](/Knowledge_Base/images/PMA-micro-s9a8s-14.png)

        Move the value to esp, but before it moved we can actually edit the value being sent over
        
        ![alt text](/Knowledge_Base/images/PMA-micro-s9a8s-16.png)

        To edit what's being printed out, we need to know how many bytes we are changing. In this case "Hello, World!" is 13 Bytes
        
        ![alt text](/Knowledge_Base/images/PMA-micro-s9a8s-15.png)



!!! info ""

    ### SikoMode

    ??? info ""

    #### 







    ??? info ""

    #### 









!!! info ""

    ### Binary Patching & Anti-analysis


    ??? info ""

    #### 







    ??? info ""

    #### 







!!! info ""

    ### Gone Phishing: Maldoc Analysis

    ??? info ""

    #### 













    ??? info ""

    #### 













    ??? info ""

    #### 








!!! info ""

    ### What The Shell? Shellcode Analysis

    ??? info ""

    #### 













    ??? info ""

    #### 













    ??? info ""

    #### 







!!! info ""

    ### Off-Script: Scripted Malware Delivery Mechanisms


    ??? info ""

    #### 













    ??? info ""

    #### 













    ??? info ""

    #### 








!!! info ""

    ### Stay Sharp: Reversing C# Malware

    ??? info ""

    #### 













    ??? info ""

    #### 













    ??? info ""

    #### 








!!! info ""

    ### Go Time: Analyzing Go Malware

    ??? info ""

    #### 













    ??? info ""

    #### 













    ??? info ""

    #### 







!!! info ""

    ### Get Mobile! Mobile Malware Analysis

    ??? info ""

    #### 













    ??? info ""

    #### 













    ??? info ""

    #### 










!!! info ""

    ### The Bossfight! Analyzing Real-World Malware Samples

    ??? info ""

    #### 













    ??? info ""

    #### 













    ??? info ""

    #### 








!!! info ""

    ### Automation: Sandboxes & Pipelines

    ??? info ""

    #### 













    ??? info ""

    #### 













    ??? info ""

    #### 










!!! info ""

    ### Tell The World: Rule Writing & Report Publishing
    ??? info ""

    #### 













    ??? info ""

    #### 













    ??? info ""

    #### 













??? info "mindmaps"

    ![alt text](/Knowledge_Base/images/PMA_Summary_20.png)

    ![alt text](/Knowledge_Base/images/PMA_Summary_21.png)
